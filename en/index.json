[{"content":"","permalink":"https://iendi.github.io/en/posts/tech/%E4%B8%AD%E9%97%B4%E4%BB%B6/dashboard/","summary":"","title":"Dashboard"},{"content":"基本组件 Cluster 基本组成 通过kubectl，对控制平面进行操作\n输入kubelctl apply -f xxx.yaml后，发生了什么？\n首先通过HTTP请求，发送至控制平面的API Server 通过Scheduler，利用ETCD中的数据，寻找合适的Node 通过Controller Mgr，控制Node内部的Kubelet Kubelet基于Container runtime拉取镜像，完成Pod的创建 创建Cluster 在本地调试开发时，可以使用kind进行安装，会安装一个cluster到docker中\nPods 一个Pod内，包含多个Container（可以理解为Docker镜像）\nDevelopments Service Ingress HTTP请求后，先通过Ingress控制器，转换至某个Node的Kube Proxy中，通过其转发到某个Pod上\n目前higress：\n如果我们的业务经常会增加不同的监听端口，那对于higress来说，不仅仅要调整kind: Gateway 资源内的port， 还要同步调整 higress-gateway service的port，相当\n切换集群：\n# 获取所有clusters kubectl config get-contexts # 获取当前集群信息 kubectl cluster-info # 更改集群 kubectl config use-context kind-higress # kubectl get deployments --all-namespaces 启动higress console\n先frontend运行npm install, npm run build backend运行maven package\n转发集群内端口：\nkubectl port-forward deployment/higress-controller -n higress-system 15014 higress-core.gateway.hostNetwork设为true，重启minikube\n使用k9s\n启动k8s \u0026amp; higress\nminikube start kubectl get svc -n higress-system # 开启foo-app kubectl apply -f foo-app.yaml # 测试 curl http://localhost/foo -H \u0026#39;host: foo.bar.com\u0026#39; 测试httpdns\n参考文献：\nKubernetes 练习手册\nKubernetes(k8s)是什么？\n","permalink":"https://iendi.github.io/en/posts/tech/%E4%B8%AD%E9%97%B4%E4%BB%B6/k8s/","summary":"基本组件 Cluster 基本组成 通过kubectl，对控制平面进行操作 输入kubelctl apply -f xxx.yaml后，发生了什么？ 首先通过HTTP请求，发送至","title":"K8s"},{"content":"回溯做了一星期，都是用dfs，今天刚好每日一题是bfs\n994. 腐烂的橘子 - 力扣（LeetCode）\nm x n 网格 grid 中：\n值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。 每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。\n返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。\n输入：grid = [[2,1,1],[1,1,0],[0,1,1]]\n输出：4\nbfs其实就是层序遍历 ， 用队列+迭代那一套来做 这一题，思路如下：\n遍历一遍，找：\n腐烂的橘子，加进初始队列 新鲜的橘子数，记作count bfs：\n对腐烂的橘子，四周如果有橘子 设为腐烂，并加进下一层队列 count\u0026ndash; 如果count不为0，说明有橘子未被处理\nclass Solution { public int orangesRotting(int[][] grid) { //创建链表，把污染节点放进去，并统计为1个数 int count=0, ans=0, m=grid.length, n=grid[0].length; int[][] dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}}; Queue\u0026lt;int[]\u0026gt; que = new LinkedList\u0026lt;\u0026gt;(); for(int i=0; i\u0026lt;m; i++){ for(int j=0; j\u0026lt;n; j++){ if(grid[i][j]==1) count++; else if(grid[i][j]==2) que.add(new int[]{i,j}); } } //bfs，把污染节点 while(count\u0026gt;0 \u0026amp;\u0026amp; !que.isEmpty()){ ans++; int k=que.size(); while(k--\u0026gt;0){ int[] badPoint = que.poll(); for(int[] dir:dirs){ int curPointX = badPoint[0]+dir[0], curPointY = badPoint[1]+dir[1]; if(curPointX\u0026gt;=0 \u0026amp;\u0026amp; curPointX\u0026lt;m \u0026amp;\u0026amp; curPointY\u0026gt;=0 \u0026amp;\u0026amp; curPointY\u0026lt;n \u0026amp;\u0026amp; grid[curPointX][curPointY]==1){ count--; que.add(new int[]{curPointX, curPointY}); grid[curPointX][curPointY] = 2; } } } } return count\u0026gt;0?-1:ans; } } ","permalink":"https://iendi.github.io/en/posts/lc/%E5%9B%BE/bfs/","summary":"回溯做了一星期，都是用dfs，今天刚好每日一题是bfs 994. 腐烂的橘子 - 力扣（LeetCode） m x n 网格 grid 中： 值 0 代表空单元格； 值 1 代表新鲜橘","title":"BFS搜索"},{"content":"常见命令 镜像命令\ndocker pull ：下载镜像 docker images：列出本地主机上的镜像 docker search httpd ：在docker hub上查找指定名称的镜像 docker rmi httpd：删除镜像 docker tag 860c279d2fec kend/centos:dev：设置镜像标签 镜像ID 用户名/镜像源名(repository name): 新的标签名(tag) 运行镜像，指定容器名\ndocker run -d --name dc -p 8080:8080 kend/myProject:latest /bin/echo \u0026quot;Hello world\u0026quot; -d: 不输出结果，后台模式启动，返回容器ID 后台模式：退出终端后，仍继续运行 -i 支持交互式操作 -t 开启终端 可以连在一起写➡-it -p 8080:8080：公网端口：容器内端口 比如我写了个web项目，启动在8080端口，-p 123:8080，我就能通过访问localhost:123去访问 kend/myProject:latest : 镜像名 /bin/echo \u0026quot;Hello world：在启动的容器里执行的命令，要保证镜像为linux，才能执行该语句，不过推荐CMD语句写在Dockerfile中 容器操作\ndocker ps ：查看容器状态 docker stop/start/rm name(id)：停止/启动/删除容器 如果-d后台运行后想进入容器，怎么做呢，使用docker exec：\ndocker exec -it 243c32535da7 /bin/bash 如上，运行后进入容器并启动bash\ndocker top name(id)：查看容器内进程 查看日志\ndocker logs -f -t --tail 100 name(id)\n-f：保持对日志的实时跟踪 -t：加上时间戳 --tail 100：只显示最新的100行 构建镜像 Dockerfile文件 FROM：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。\nRUN：用于执行后面跟着的命令行命令。有以下俩种格式：\nshell 格式：\nRUN \u0026lt;命令行命令\u0026gt; # \u0026lt;命令行命令\u0026gt; 等同于，在终端操作的 shell 命令。 exec 格式：\nRUN [\u0026#34;可执行文件\u0026#34;, \u0026#34;参数1\u0026#34;, \u0026#34;参数2\u0026#34;] # 例如： # RUN [\u0026#34;./test.php\u0026#34;, \u0026#34;dev\u0026#34;, \u0026#34;offline\u0026#34;] 等价于 RUN ./test.php dev offline 注意：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：\nFROM centos RUN yum -y install wget RUN wget -O redis.tar.gz \u0026#34;http://download.redis.io/releases/redis-5.0.3.tar.gz\u0026#34; RUN tar -xvf redis.tar.gz 以上执行会创建 3 层镜像。可简化为以下格式：\nFROM centos RUN yum -y install wget \\ \u0026amp;\u0026amp; wget -O redis.tar.gz \u0026#34;http://download.redis.io/releases/redis-5.0.3.tar.gz\u0026#34; \\ \u0026amp;\u0026amp; tar -xvf redis.tar.gz 如上，以 \u0026amp;\u0026amp; 符号连接命令，这样执行后，只会创建 1 层镜像\n指令\nDockerfile 指令 说明 使用 FROM 指定基础镜像，用于后续的指令构建。 MAINTAINER 指定Dockerfile的作者/维护者。（已弃用，推荐使用LABEL指令） LABEL 添加镜像的元数据，使用键值对的形式。 RUN 在构建过程中在镜像中执行命令。 docker build时运行 CMD 指定容器创建时的默认命令。（可以被覆盖） docker run 时运行CMD [\u0026quot;\u0026lt;可执行文件或命令\u0026gt;\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026hellip;]多个CMD时，仅最后一个生效 ENTRYPOINT 设置容器创建时的主要命令。（不可被覆盖） 不会被docker run的参数所覆盖多个ENTRYPOINT时，仅最后一个生效 ENV 在容器内部设置环境变量。 ENV = =\u0026hellip;\n$key1 可以访问 ARG 定义在构建过程中传递给构建器的变量，可使用 \u0026ldquo;docker build\u0026rdquo; 命令设置。 跟ENV类似，不过只在docker build时运行 ADD 将文件、目录或远程URL复制到镜像中。 COPY(自动解压版) COPY 将文件或目录复制到镜像中。 COPY \u0026lt;源路径1\u0026gt;\u0026hellip; \u0026lt;目标路径\u0026gt; WORKDIR 设置后续指令的工作目录。 WORKDIR \u0026lt;工作目录路径\u0026gt; USER 指定后续指令的用户上下文。 USER \u0026lt;用户名\u0026gt;[:\u0026lt;用户组\u0026gt;] ONBUILD 当该镜像被用作另一个构建过程的基础时，添加触发器。 创建时不运行，被FROM时运行 STOPSIGNAL 设置发送给容器以退出的系统调用信号。 HEALTHCHECK 定义周期性检查容器健康状态的命令。 举个例子：\n# Dockerfile FROM golang:1.16-buster AS builder RUN mkdir /src ADD . /src WORKDIR /src RUN go env -w GO111MODULE=auto RUN go build -o main . FROM gcr.io/distroless/base-debian10 WORKDIR / COPY --from=builder /src/main /main EXPOSE 3000 ENTRYPOINT [\u0026#34;/main\u0026#34;] COPY --from=builder /src/main /main\n多阶段构建：\n以上代码从名为builder的构建阶段的容器中，将/src/main目录下的文件复制到当前正在构建的容器的/main目录下\n构建时从其他镜像复制文件:\nCOPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf 创建镜像 docker build -t kend/centos:6.7 . -t ：指定要创建的目标镜像名 . ：Docker上下文，如果没指定Dockerfile，则在上下文中寻找 或者指定文件：\ndocker build -t kend/centos:6.7 . -f Dockerfile.copy 参考资料：\nDocker Dockerfile | 菜鸟教程 (runoob.com)\nDockerfile 多阶段构建 · Docker \u0026ndash; 从入门到实践 (docker-practice.github.io)\n","permalink":"https://iendi.github.io/en/posts/tech/%E4%B8%AD%E9%97%B4%E4%BB%B6/docker/","summary":"常见命令 镜像命令 docker pull ：下载镜像 docker images：列出本地主机上的镜像 docker search httpd ：在docker hub上查找指定名称的镜像 docker rmi httpd：删除镜像 docker","title":"Docker 基本知识"},{"content":" 子集2\n给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的 子集\n首先，子集问题 就是在回溯时对每个节点进行保存操作\n与一般子集问题相比，这个问题中包含重复元素，举个例子，当nums=[1,2,2]，就会出现：\n1 / \\ 2 2 这样的回溯树，导致添加重复元素\n因此要进行树层去重（前提是数组有序）➡ 同一层中，如果i节点与i-1节点相同，跳过\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans; public int[] nums; public void helper(Deque\u0026lt;Integer\u0026gt; path, int startIdx){ ans.add(new ArrayList\u0026lt;\u0026gt;(path)); if(startIdx\u0026gt;=nums.length) return; for(int i=startIdx; i\u0026lt;nums.length; i++){ path.add(nums[i]); helper(path, i+1); path.removeLast(); while(i+1\u0026lt;nums.length \u0026amp;\u0026amp; nums[i+1]==nums[i]) i++; } return; } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { Arrays.sort(nums); ans = new ArrayList\u0026lt;\u0026gt;(); this.nums = nums; helper(new ArrayDeque\u0026lt;\u0026gt;(), 0); return ans; } } 491. 非递减子序列\n给定 nums ，找出并返回所有nums中不同的非递减子序列\n如： nums = [4,6,7,7] 输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]\n这题也是要去重的，相比于子集2，这题不能预先排序，因此直接相邻的i和i+1判别不现实，如nums= [1,2,1,1]\n1 1 （第3个1） / \\\t/ 2 1 1 这题是对树根和树层进行去重，而树层去重，可以看作带父节点的树根去重➡每次循环根节点前，增加一个map数组，记录某个节点是否使用过\n//nums[i]的值在-100~100之间，用map数组，提高查找时间 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans; public int[] nums; public void dfs(Deque\u0026lt;Integer\u0026gt; path, int startIdx){ if(path.size()\u0026gt;1) ans.add(new ArrayList\u0026lt;\u0026gt;(path)); boolean[] map = new boolean[201]; for(int i=startIdx; i\u0026lt;nums.length; i++){ if(map[nums[i]+100] || (!path.isEmpty() \u0026amp;\u0026amp; path.getLast()\u0026gt;nums[i])) continue; map[nums[i]+100] = true; path.add(nums[i]); dfs(path, i+1); path.removeLast(); } return; } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; findSubsequences(int[] nums) { ans = new ArrayList\u0026lt;\u0026gt;(); this.nums = nums; dfs(new ArrayDeque\u0026lt;\u0026gt;(), 0); return ans; } } ","permalink":"https://iendi.github.io/en/posts/lc/%E5%9B%9E%E6%BA%AF/repeat/","summary":"子集2 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的 子集 首先，子集问题 就是在回溯时对每个节点进行保存操作 与一般子集问题相","title":"回溯中的去重问题"},{"content":"首先是图的两种写法，给定int[][] edges\n//邻接表 //邻接矩阵 Dijkstra是单源最短路径，表示某个节点i到其他节点k的距离\n743. 网络延迟时间 - 力扣（LeetCode）\n3112. 访问消失节点的最少时间 - 力扣（LeetCode）\n","permalink":"https://iendi.github.io/en/posts/lc/%E5%9B%BE/1/","summary":"首先是图的两种写法，给定int[][] edges //邻接表 //邻接矩阵 Dijkstra是单源最短路径，表示某个节点i到其他节点k的距离 743. 网络延迟时间","title":"Dijkstra算法"},{"content":" 1702. 修改后的最大二进制字符串 - 力扣（LeetCode）\n给一个二进制字符串，可以做以下操作\n操作1：把00-\u0026gt;10 操作2：把10-\u0026gt;01 可以无限次上述操作，要求返回修改后最大的字符串\n贪心，前面的1越多，数值越大：\n通过操作2，把后面的0前移，让前面的0尽可能多 通过操作1，把集中在一块的0，变为111...10（只有最后一位是0） 假设第一个0的位置为x，0的数量为k,最后得到全1数组，只有x+k-1的位置为0\nclass Solution { public String maximumBinaryString(String binary) { int start = binary.indexOf(\u0026#39;0\u0026#39;); if(start==-1) return binary; int n = binary.length(), k=0; char[] arr = binary.toCharArray(); for(int i=start; i\u0026lt;n; i++){ if(arr[i]==\u0026#39;0\u0026#39;) k++; arr[i] = \u0026#39;1\u0026#39;; } arr[start+k-1] = \u0026#39;0\u0026#39;; return new String(arr); } } ","permalink":"https://iendi.github.io/en/posts/lc/%E8%B4%AA%E5%BF%83/0410/","summary":"1702. 修改后的最大二进制字符串 - 力扣（LeetCode） 给一个二进制字符串，可以做以下操作 操作1：把00-\u0026gt;10 操作2：把10-\u0026gt;0","title":"0410每日一题"},{"content":"复习一下忘记的知识点。\n引用传值 Java中都是传值的，但由于传递的是一份对象引用的拷贝进行传递的，但是原引用和拷贝的引用依旧指向的是堆中的同一份值，因此修改值后，也会更改原有值。\n基本类型如下，这些类型一定是传值：\nbyte short int long float double char boolean 像int数组、String这种，都不是基本类型。传参时直接拷贝，会修改原有值\npublic static void AddArray(int[] a){ for(int i=0; i\u0026lt;a.length; i++) a[i]++; } public static void main(String[] args) { int[] a = {1,2,3,4,5}; AddArray(a); for(int num:a) System.out.println(num); } //输出2，3，4，5，6 注意：如果是以下情况，原数组的值不变\n// for each public static void AddArray(int[] a){ for(int num:a) num++; } // 创建副本 public static void AddArray(int[] a){ int[] tmp = a.clone(); for(int i=0; i\u0026lt;tmp.length; i++) tmp[i]++; } 原因是for-each循环的时候，每次都是新建一个int赋值，对应的地址不同\n","permalink":"https://iendi.github.io/en/posts/tech/java--jvm/java_review/","summary":"复习一下忘记的知识点。 引用传值 Java中都是传值的，但由于传递的是一份对象引用的拷贝进行传递的，但是原引用和拷贝的引用依旧指向的是堆中的同一","title":"Java基础知识复习"},{"content":" 1483. 树节点的第 K 个祖先 - 力扣（LeetCode）\n给定n=7， 每个元素的祖先[-1,0,0,1,1,2,2]\n对应树为：\n要求给定元素n，求出其第k个祖先\n本题的主要思想是倍增。如果采用暴力解，求5的第10个祖先，要先求parent[5]，再求parent[parent[5]]\u0026hellip;以此类推，最终导致超时。\n优化上述步骤，$k=10=(1010)_2=8+2$，即我们可以先求5的第二个祖先，再求该祖先的第10个祖先\n创建数组$pa = n*m$，其中n为输入的元素个数，m为k（第k个祖先）的二进制位数。第i行j列表示第i个元素的第$2^j$个祖先。\n*因为k\u0026lt;n，因此我们让m=n的二进制位数\n第2个祖先=第1个祖先的第1个祖先 第4个祖先=第2个祖先的第2个祖先 \u0026hellip; 因此我们按列遍历，每次预处理所有元素的第$2^j$个祖先\nclass TreeAncestor { private int[][] pa; public TreeAncestor(int n, int[] parent) { int m = 32 - Integer.numberOfLeadingZeros(n); // n 的二进制长度 pa = new int[n][m]; for(int i=0; i\u0026lt;n; i++) pa[i][0] = parent[i]; for(int j=0; j\u0026lt;m-1; j++){ for(int i=0; i\u0026lt;n; i++){ int p = pa[i][j]; pa[i][j+1] = p\u0026lt;0?-1:pa[p][j]; } } } public int getKthAncestor(int node, int k) { int m = 32 - Integer.numberOfLeadingZeros(k); for(int i=0; i\u0026lt;m; i++){ if(((k\u0026gt;\u0026gt;i)\u0026amp;1)==1) node = pa[node][i]; if(node\u0026lt;0) break; } return node; } } ","permalink":"https://iendi.github.io/en/posts/lc/%E5%85%B6%E4%BB%96/1/","summary":"1483. 树节点的第 K 个祖先 - 力扣（LeetCode） 给定n=7， 每个元素的祖先[-1,0,0,1,1,2,2] 对应树为： 要求给定元素n，求出其第k","title":"位运算\u0026倍增"},{"content":"整体架构 DDPM可分为以下两个部分\n其中Denoise内部：输入图片+step，预测其噪声\n为什么step也是一个重要的输入：从噪声到原图，所要预测的噪声强度是不同的 训练和推理部分如下所示\n训练过程 训练过程如下所示，Unet里有一个位置编码，是关于时间步的，每个时间步是有一个线性调度器的，每个时间添加的噪声的方差是不一样的，所以将时间步作为编码嵌入的话，可以将模型预测的噪声更加的准确\n其中，损失函数如下：\n$$ \\text { Loss }=\\left\\|\\varepsilon-\\varepsilon_{\\theta}\\left(x_t, t\\right)\\right\\|^2=\\left\\|\\varepsilon-\\varepsilon_{\\theta}\\left(\\sqrt{\\bar{\\alpha}_t}x_0+\\sqrt{1-\\bar{\\alpha}_t}\\varepsilon_t, t\\right)\\right\\|^2 $$\nt为step，t越大，$a_T$越小，加的噪声越多\n先进行forward process，生成每个step对应的图片和噪声数据集，即target noise 实际训练时，t是随机取值，不用按顺序从大到小 目标是noise predictor预测的噪声值接近真实噪声 noisy image 如下： 数学推导 $\\alpha_t=1-\\beta_t, \\beta_t$要越大越好，论文中从0.0001到0.02； 方差参数$\\beta_t$可以固定为一个常数，也可以选择作为时间段的一个时间表。可以定义一个方差表，它可以是线性的、二次的、余弦的等等 最初的DDPM作者利用了一个从到增加的线性时间表，$\\beta_t$从$10^{-4}$到$0.02$线性增加 $\\bar{\\alpha}=\\prod_{s=1}^t \\alpha_s$，为累乘 $x_t=\\sqrt{\\alpha_t} x_{t-1}+\\sqrt{1-\\alpha_t} \\varepsilon_t, \\varepsilon_t \\sim N(0,1)$，每一时刻的噪声均独立 推导过程如下，从第一步到第二步用到了重参数技巧：\n$\\begin{aligned} q\\left(x_t \\mid x_{t-1}\\right) \u0026amp; =N\\left(x_t ; \\sqrt{\\alpha_t} x_{t-1},\\left(1-\\alpha_t\\right) I\\right) \\\\\\ \u0026amp; =\\underbrace{\\sqrt{\\alpha_t} x_{t-1}}_{x_{t-2} \\text { 来表示 } x_{t-1}}+\\sqrt{1-\\alpha_t} \\varepsilon_t \\\\\\ \u0026amp; =\\sqrt{\\alpha_t}\\left(\\sqrt{\\alpha_{t-1}} x_{t-2}+\\sqrt{1-\\alpha_{t-1}} \\varepsilon_{t-1}\\right)+\\sqrt{1-\\alpha_t} \\varepsilon_t \\\\\\ \u0026amp; =\\sqrt{\\alpha_t \\alpha_{t-1}} x_{t-2}+\\underbrace{\\sqrt{\\alpha_t-\\alpha_t \\alpha_{t-1}} \\varepsilon_{t-1}+\\sqrt{1-\\alpha_t} \\varepsilon_t}_{\\text {两个独立正态分布相加 }} \\\\\\ \u0026amp; =\\sqrt{\\alpha_t \\alpha_{t-1}} x_{t-2}+\\sqrt{1-\\alpha_t \\alpha_{t-1}} \\varepsilon \\\\\\ \u0026amp; \\ldots \\\\\\ \u0026amp; =\\sqrt{\\bar{\\alpha}_t} x_0+\\sqrt{1-\\bar{\\alpha}_t} \\varepsilon \\\\\\ \u0026amp; \\therefore q\\left(x_t \\mid x_0\\right)=N\\left(x_t ; \\sqrt{\\bar{\\alpha}_t} x_0, \\sqrt{1-\\bar{\\alpha}_t} I\\right) \\end{aligned}$\n推理过程（采样） 采样过程中，根据给定的噪声和condition（step, text\u0026hellip;），输出对应的采样图\n根据噪声$x_t$预测$x_{t-1}$ 加上采样的噪声$z$，如果是最后一次采样（$t==1$），就不添加噪声 数学推导 首先我们来看常见生成模型的目标函数，其中$z$为图像的隐空间表示，Network一般为一个Decoder\n给定网络参数$\\theta$，我们要让输出$x$的分布$P_{\\theta}(x)$尽可能接近$P_{data}(x)$： $$ \\text { Sample }\\left\\{x^1, x^2, \\ldots, x^m\\right\\} \\text { from } P_{\\text {data }}(x)\\\\\\ \\theta^{*}=\\arg \\max _{\\theta} \\prod_{i=1}^m P_{\\theta}\\left(x^i\\right)=\\arg \\max _{\\theta} \\log \\prod_{i=1}^m P_{\\theta}\\left(x^i\\right) \\\\=\\arg \\max _{\\theta} \\sum_{i=1}^m \\log P_{\\theta}\\left(x^i\\right)$$ 我们从输入随机采样得到图片$x^i$，目标是$P_{\\theta}(x^i)$有最大值，即最大似然估计\n*补充知识点：\n期望是对随机变量的数值进行加权平均的概念。当随机变量是连续型变量时，期望可以通过积分来计算。设$X$是一个连续型随机变量，其概率密度函数为$f(x)$。对于一个函数$g(X)$，它关于X的期望可以表示为 $$ E[g(X)] = ∫g(x) f(x) dx $$\n**重参数化：**使计算过程可导 $$z \\sim N\\left(z, \\mu, \\sigma^2 I\\right) \\longrightarrow z=\\mu+\\sigma \\cdot \\epsilon, \\epsilon \\sim N(0, I)$$\n求$P_{\\theta}(x)$的下界，使其最大：\n同样的，推导可得，DDPM的下界：\n以下公式参考[2]，详细过程见原文，这边只写简化后的结果 $$-\\log \\left(p_{\\theta}\\left(x_0\\right)\\right) \\leq \\underbrace{\\log \\left(\\frac{q\\left(x_{1: T} \\mid x_0\\right)}{p_{\\theta}\\left(x_{0: T}\\right)}\\right)}_{\\text {变分下界, 可以优化它 }} \\\\ \\log \\left(\\frac{q\\left(x_{1: T} \\mid x_0\\right)}{p_{\\theta}\\left(x_{0: T}\\right)}\\right) =\\underbrace{{D_{K L}\\left(q\\left(x_t \\mid x_0\\right) \\| p\\left(x_T\\right)\\right)}}_{q \\text { 只是个正向过程没有可学习参数 }}+\\sum_{t=2}^T D_{K L}\\left(q\\left(x_{t-1} \\mid x_t, x_0\\right) \\| p_{\\theta}\\left(x_{t-1} \\mid x_t\\right)\\right)-\\log \\left(p_{\\theta}\\left(x_0 \\mid x_1\\right)\\right)$$\n第一项KL散度可以忽略，因为q只是个正向过程，没有可学习参数，换句话说就是它是固定的。\n第二项KL散度，左边和右边都是正态分布，左边的$q\\left(x_{t-1} \\mid x_t, x_0\\right)$是真实值，我们想求的；右边的${p_{\\theta}\\left(x_{t-1} \\mid x_t\\right)}$是神经网络估计的\n$$\\sum_{t=2}^T D_{K L}(\\underbrace{q\\left(x_{t-1} \\mid x_t, x_0\\right)}_{N\\left(x_{t-1} ; \\tilde{\\mu_t}\\left(x_t, x_0\\right), \\tilde{\\beta_t} I\\right)} \\| \\overbrace{p_{\\theta}\\left(x_{t-1} \\mid x_t\\right)}^{N\\left(x_{t-1} ; \\mu_{\\theta}\\left(x_t, t\\right), \\beta I\\right.})$$\n首先，通过变化，可以获得$\\tilde{\\mu_t}$的值，这里的$\\varepsilon$为真实噪声值 $$\\\\ \\begin{aligned} \\underbrace{\\tilde{\\mu_t}\\left(x_t, x_0\\right)}_{\\text {不再依赖 } x_0} \u0026amp; \u0026amp; =\\frac1{\\sqrt{\\alpha_t}}\\left(x_t-\\frac{\\beta_t}{\\sqrt{1-\\bar{\\alpha}_t}} \\varepsilon\\right) \\end{aligned}$$\n我们需要减小KL散度，由于方差是固定的，我们无法优化，所以需要将它们的均值之差减小，原论文中使用的是简单的均方误差： $$\\begin{aligned} L_t \u0026amp; =\\frac1{2 \\sigma_t^2}\\left\\|\\tilde{\\mu}_t\\left(x_t, x_0\\right)-\\mu_{\\theta}\\left(x_t, t\\right)\\right\\|^2 \\\\ \u0026amp; =\\frac1{2 \\sigma_t^2}\\left\\|\\frac1{\\sqrt{\\alpha_t}}\\left(x_t-\\frac{\\beta_t}{\\sqrt{1-\\bar{\\alpha}_t}} \\varepsilon\\right)-\\frac1{\\sqrt{\\alpha_t}}\\left(x_t-\\frac{\\beta_t}{\\sqrt{1-\\bar{\\alpha}_t}} \\varepsilon_{\\theta}\\left(x_t, t\\right)\\right)\\right\\|^2 \\\\ \u0026amp; =\\frac{\\beta_t^2}{2 \\sigma_t^2 \\alpha_t\\left(1-\\bar{\\alpha}_t\\right)} \\underbrace{\\left\\|\\varepsilon-\\varepsilon_{\\theta}\\left(x_t, t\\right)\\right\\|^2}_{m s e} \\\\ \u0026amp; -\u0026gt;\\left\\|\\varepsilon-\\varepsilon_{\\theta}\\left(x_t, t\\right)\\right\\|^2=\\left\\|\\varepsilon-\\varepsilon_{\\theta}\\left(\\sqrt{\\bar{\\alpha}_t} x_0+\\sqrt{1-\\bar{\\alpha}_t} \\varepsilon_t, t\\right)\\right\\|^2 \\end{aligned}$$\n最终，DDPM的过程可概括为如下： $$ x_{t-1}=N\\left(x_{t-1} ; \\frac1{\\sqrt{\\alpha_t}}\\left(x_t-\\frac{\\beta_t}{\\sqrt{1-\\bar{\\alpha}_t}} \\varepsilon_{\\theta}\\left(x_t, t\\right)\\right), \\Sigma_{\\theta}\\left(x_t, t\\right)\\right) $$\n每个时间步通过$x_t$和$t$来预测高斯噪声$\\varepsilon_{\\theta}$，根据上面公式计算得到均值$\\mu$ 得到方差$\\Sigma_{\\theta}\\left(x_t, t\\right)$； 代入公式得到$q\\left(x_{t-1} \\mid x_t, x_0\\right)$，利用重参数化得到$x_{t-1}$ 因为我们计算了$D_{K L}\\left(q\\left(x_{t-1} \\mid x_t, x_0\\right) \\| p_{\\theta}\\left(x_{t-1} \\mid x_t\\right)\\right)$，故可以利用$q\\left(x_{t-1} \\mid x_t\\right)$来近似$p\\left(x_{t-1} \\mid x_t\\right)$ 参考资料:\nML 2023 Spring (ntu.edu.tw)\n保姆级讲解 Diffusion 扩散模型（DDPM）\n","permalink":"https://iendi.github.io/en/posts/ai/diffusion/","summary":"整体架构 DDPM可分为以下两个部分 其中Denoise内部：输入图片+step，预测其噪声 为什么step也是一个重要的输入：从噪声到原图，所要","title":"DDPM"},{"content":"整体结构 分为三个部分，Linear Projection of Flattened Patches(Embedding层)、Encoder和MLP Head分类头\n下图是不同版本ViT的参数设置。\nLayers：Transformer Encoder中重复堆叠Encoder Block的次数 Hidden Size：通过Embedding层后每个token的dim MLP size：Transformer Encoder中MLP Block第一个全连接的节点个数（是Hidden Size的四倍） Heads：Transformer中Multi-Head Attention的heads数 Embedding层 首先将图片分为不同的patch，这里有两个参数\npatch size：一个patch的大小 stride：步长，如果和patch size一样，则不重叠（可以重叠） 接着，将每个patch拉伸至一维，并通过线性层，得到Embedding层的输出\n实际代码中，上述过程直接通过卷积进行。假设使用ViT-B16,参数设置如下\nkernel size kernel num stride 16×16 768 16 原图尺寸[224,224,3]，卷积后➡[14,14,768]，将h和w进行展平➡[196,768] 加入[CLS]标签的token➡[197,768] 加入Position Embedding➡[197,768] 至此，得到Embedding层的输出\nEncoder层 Encoder层结构如下，DropPath可以理解为随机丢弃一些残差连接。一个Transformer Encoder是由多个Encoder Block组成的\nMLP Head 一般是直接Linear+Softmax。有些数据集比较大，会改成Linear+tanh+Linear+Softmax\nHybrid模型 改不同的backbone，先用backbone进行特征提取，然后将其输入至ViT中\n参考资料:\n11.1 Vision Transformer(vit)网络详解\nViT用于图片分类\n","permalink":"https://iendi.github.io/en/posts/ai/vit/","summary":"整体结构 分为三个部分，Linear Projection of Flattened Patches(Embedding层)、Encoder和MLP Head分类头 下图是不同版本ViT的参","title":"ViT"},{"content":"BERT的全称为Bidirectional Encoder Representation from Transformers，主要针对Transformer的Encoder部分进行预训练，包括以下两个部分：\nMasked Language Model：类似完形填空，预测被遮挡的单词 Next Sentence Prediction：预测下一个句子 首先对输入的句子进行token化，具体操作如下图所示\nMasked Language Model BERT会以15%的概率随机地选中某个token位置，替换为[MASK]。假设输入为the cat sat on the mat，将cat进行mask。\n经过Encoder层后得到特征向量$u_M$，根据attention的特性，$u_M$包括上下文信息，知道整句话的意思，因此将其输入至SoftMax分类器，得到概率分布p\n最后，把预测的值和ground truth进行交叉熵计算loss，然后梯度下降更新模型参数\n==注==：这里更新参数，包括Encoder层和Embedding层。因此，最后训练得到的Embedding层可以有效表示不同词向量之间的关联性\n预训练的目标会令产生的语言表征对[MASK]敏感，但是却对其他token不敏感，因此BERT在替换时，采用以下策略\n80%是[MASK]。my dog is hairy——\u0026gt;my dog is [MASK] 10%是随机的其他token。my dog is hairy——\u0026gt;my dog is apple 10%的是原来的token。my dog is hairy——\u0026gt;my dog is hairy 这种策略令BERT不再只对[MASK]敏感，而是对所有的token都敏感，以至能抽取出任何token的表征信息\nNext Sentence Prediction MLM任务倾向于抽取token层次的表征，因此不能直接获取句子层次的表征。因此BERT中加入NSP任务，预测两个句子是否连在一起\n将两个句子通过[SEP]连接起来，如果是上下句，target为true\n得到的特征向量c包括所有输入的信息，将其输入至二分类器中，与真实值对比，并进行参数更新\n在训练时，常将MLM和NSP结合起来，如下所示。也可以加多个MASK或句子，对应的加多个loss\n经过预训练后，BERT在每个位置上生成对应于输入标记的表示向量，可以理解为提取出了语义信息。这些表示向量可以被用于各种下游任务，如文本分类、命名实体识别等\n","permalink":"https://iendi.github.io/en/posts/ai/bert/","summary":"BERT的全称为Bidirectional Encoder Representation from Transformers，主要针对Transformer的Encoder部分进行预训练，包括","title":"Bert"},{"content":"Seq2Seq模型 定义 包括两个部分：\n编码器：将一个变长、可变类型的输入序列编码成一个固定长度、定长的向量，该向量中包含了输入序列的所有信息 解码器：每次输出一个字符，并把该字符作为下一次的输入，以此往复直到输出序列的结束标志为止 起始/终止符 以机器翻译为例，英翻中：\ntarget input：加[CLS]表示句子的开始 target output：加[SEP]表示结束 在==训练==时，用正确的target input（即ground truth）做输入，然后求loss进行参数更新，称为Teacher Forcing\n在==推理==时，[CLS]做输入，每次输出一个字符，并把该字符作为下一次的输入，直至预测到[SEP]\n如下图所示，输入的信息累积到$h_m$中，作为隐藏状态传给Decoder\nAttention 传统的Seq2Seq模型的Decoder部分，在生成下一状态时，只用到当前状态。而使用==attention==之后，Decoder每生成一个状态，都会重新计算和Encoder之间的相关性。\n计算$a_i$的公式如下。其中，$W_K$和$W_Q$是训练中得到的，$A$为参数矩阵，$k_i$、$q_i$均为列向量 $$ \\begin{array}l fk_i=fW_K \\cdot fh_i, \\text { for } i=1 \\text { to } m \\\\ fq_0=fW_Q \\cdot fs_0\\\\ fK=\\left \\{ k_1,k_2,\u0026hellip;,k_m \\right \\} \\\\ \\tilde{\\alpha}_i=fK^T fq_0 \\\\ \\left[\\alpha_1, \\cdots, \\alpha_m\\right]=\\operatorname{Softmax}\\left(\\left[\\tilde{\\alpha}_1, \\cdots, \\tilde{\\alpha}_m\\right]\\right) \\end{array} $$\n计算得到$a_i$之后，计算$s_0$对应的$c_0$，并计算下一个状态$s_1$\n==注==：这里相比于RNN，attention在计算中多考虑了$c_0$ $$ fv_i=fW_V\\cdot fh_i\\\\ fc_0=\\alpha_1 fv_1+\\cdots+\\alpha_m fv_m\\\\ fs_1=\\tanh \\left(fA^{\\prime} \\cdot\\left[\\begin{array}l fx_1^{\\prime} \\\\ fs_0 \\\\ fc_0 \\end{array}\\right]+fb\\right) $$ 得到$s_1$之后，重新计算$a_i$，$k_i$不变，其他重新计算，得到$s_2$，以此类推\nSelf-Attention 隐藏变量$h_i$的计算公式如下 $$ fh_i=\\tanh \\left(fA \\cdot\\left[\\begin{array}l fx_i \\\\ fc_{i-1} \\end{array}\\right]+fb\\right) $$ 要得到$c_i$，首先要计算attention系数$a_i$，通过下列公式得到，其中align表示相关性公式 $$ a_i=align \\{h_i, (h_0,h_1,\u0026hellip;h_i) \\} $$ 接着，计算得到$c_i$，并更新隐藏变量$h_i$ $$ fc_l=\\left\\{\\begin{matrix} h_1,\\qquad l=1 \\\\\\\n\\sum_{i=1}^l{a_i}{h_i} , l\u0026gt;1 \\end{matrix}\\right. $$\nTransformer模型 Attention 和Seq2Seq模型类似，我们首先定义一个attention层，$k_:1$中的冒号表示其是一个列向量\n输入序列有两个，分别是Encoder Input和Decoder Input。接着，通过公式计算$a_:1$ $$ \\boldsymbol{\\alpha}_{: 1}=\\operatorname{Softmax}\\left(fK^T fq_{: 1}\\right) \\in bR^m $$ 最后，计算得到$c_:1$。其中，$a_{11}$表示列向量$a_:1$的第一个元素 $$ fc_{: 1}=\\alpha_{11} fv_{: 1}+\\cdots+\\alpha_{m 1} fv_{: m}=fV \\boldsymbol{\\alpha}_{: 1} $$\n综上，attention层的参数如下\n输入：包括Encoder Input和Decoder Input，$fC=Attn（fX,f{X\u0026rsquo;}）$ 输出：$fC=\\left[fc_{:1}, fc_{:2}, \\cdots, fc_{:t}\\right]$ Self-Attention 与Attention层类似，不同的是只有一个输入\n输入：$fC=Attn（fX,fX）$，可以看作两个输入都是X的Attention 输出：$fC=\\left[fc_{:1}, fc_{:2}, \\cdots, fc_{:t}\\right]$ Multi-Head 使用多头注意力，模型可以学习到不同的注意力权重，从而从不同的角度和视角来关注输入序列的信息\n以Multi-Head Self-Attention为例\nMulti-Head Self-Attention由L个Single-Head Self-Attention组成，即有L个$W_K、W_Q、W_V$矩阵\n最终得到L个$c_{:i}$，将其concat在一起\n搭建Encoder 单个Block由一个多头Self-Attention和全连接层组成，由于输入和输出的维度一样，可以采用残差结构\n搭建Decoder 单个的Decoder Block如下图所示\n==注==：对输入的$X\u0026rsquo;$，一般做的是Multi-Head Masked Self-Attention。即预测第i个单词不能获得i+1个单词的信息。因此Decoder部分被称为单向Transformer\n最后，将Encoder和Decoder组合起来，得到下图的结构\n参考资料：\nRNN模型与NLP应用\n","permalink":"https://iendi.github.io/en/posts/ai/transformer/","summary":"Seq2Seq模型 定义 包括两个部分： 编码器：将一个变长、可变类型的输入序列编码成一个固定长度、定长的向量，该向量中包含了输入序列的所有信息 解","title":"Transformer基础知识"},{"content":"利用pyside6对python程序进行快速上手开发，实现模型的部署，请先安装pyside6相关依赖：\npip install pyside6 pip install qt-material Pyside6基础知识 窗口框/组件 pyside6的窗口框为Widgets, 是可视化的用户界面组件。一般我们都是用Widges类创建一个主界面，然后在其基础上添加组件，创建代码如下：\nw = QWidget() # 设置窗口标题 w.setWindowTitle(\u0026#34;PySide6程序\u0026#34;) # 展示窗口 w.show() 基本组件：\n都位于位于 PySide6.QtWidgets 包内\n按钮： QPushButton，多用于点击后触发事件 标签：QLabel，显示文字、图片、视频 输入框： QLineEdit，输入文字 下拉框：QComboBox ，下拉选择某个选项 完整演示程序如下：\nimport sys from PySide6.QtWidgets import QApplication, QWidget, QLabel, QPushButton, QLineEdit, QComboBox from qt_material import apply_stylesheet # 创建主窗口类 class MainWindow(QWidget): def __init__(self): super().__init__() # 设置窗口标题 self.setWindowTitle(\u0026#34;PySide6程序\u0026#34;) # 窗口的大小 self.resize(500, 300) # 添加组件,需要在构造时添加父组件，即self # 文本 self.label = QLabel(\u0026#34;账号\u0026#34;, self) self.label.setGeometry(50, 50, 50, 50) # 文本框 self.edit = QLineEdit(self) self.edit.setPlaceholderText(\u0026#34;请输入账号\u0026#34;) self.edit.setGeometry(110, 50, 150, 50) # 下拉框 self.combo_box = QComboBox(self) self.combo_box.addItem(\u0026#34;男\u0026#34;) self.combo_box.addItem(\u0026#34;女\u0026#34;) self.combo_box.setGeometry(290, 50, 50, 50) # 按钮 self.btn = QPushButton(\u0026#34;注册\u0026#34;, self) self.btn.setGeometry(360, 50, 70, 50) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) w = MainWindow() # 展示窗口 w.show() # 设置主题色为蓝色 apply_stylesheet(app, theme=\u0026#39;light_blue_500.xml\u0026#39;) # 程序进行循环等待状态，用于持久显示 sys.exit(app.exec()) 信号与槽 其实就是点击按钮后，发出信号，对应执行的函数称之为槽。上述程序，我们希望在点击注册后，控制台输出账号，代码如下：\n==注意==：绑定槽函数时，不用加 \u0026ldquo;()\u0026rdquo;\n# 首先，在init中添加绑定函数 # 注意：这里没有() self.btn.clicked.connect(self.click_my_btn) # 在主窗口类中，添加click_my_btn函数 def click_my_btn(self): print(self.edit.text()) 布局 上面程序中我们使用setGeometry函数设置组件的位置，但这种方法会导致我们在放大/缩小窗口时组件位置错乱，因此我们使用布局，使界面能自适应窗口大小。\nfrom PySide6.QtWidgets import QHBoxLayout, QVBoxLayout, QGridLayout 其中QHBoxLayout为水平布局， QVBoxLayout是垂直布局，QGridLayout为栅格布局，可互相叠加嵌套，下面来看一个例子：\nframe是QFrame类的实例，可以理解成一个小窗口，方便对同一frame中的组件进行样式、布局的统一管理。\n上图中，frame 1-3 内为水平布局，frame 4为栅格布局，frame 1-4 组合一起为垂直布局，忽略具体的组件，代码实现如下：\n# 水平布局，传入参数为父组件，即在该组件中应用布局 self.hLayout_1 = QtWidgets.QHBoxLayout(self.frame_1) self.hLayout_1.addWidget(菜单栏) # 添加子组件，此处为伪代码 self.hLayout_1.addWidget(历史数据) # 栅格布局，addWidget（子组件，起始行，起始列，占的行数，占的列数） self.gLayout_4 = QtWidgets.QGridLayout(self.frame_4) self.gLayout_4.addWidget(%, 0, 0, 1, 1) self.gLayout_4.addWidget(CE, 0, 1, 1, 1) self.gLayout_4.addWidget(C, 0, 2, 1, 1) # 垂直布局 self.vLayout = QtWidgets.QVBoxLayout(self) self.vLayout.addWidget(self.frame_1) self.vLayout.addWidget(self.frame_2) self.vLayout.addWidget(self.frame_3) self.vLayout.addWidget(self.frame_4) 无边框化 这一步是为了程序更加美观，如果没有需求可以跳过。\n首先通过属性设置，将原有边框去除：\nfrom PySide6.QtCore import Qt self.setWindowFlag(Qt.FramelessWindowHint) self.setAttribute(Qt.WA_TranslucentBackground) # 背景设置半透明 接着添加移动窗口功能：\n# 重写QWidge中方法 # ---移动功能--- def mousePressEvent(self, event): # 鼠标左键按下时获取鼠标坐标 if event.button() == Qt.LeftButton: self._move_drag = True self.m_Position = event.globalPosition().toPoint() - self.pos() event.accept() self.setCursor(QtGui.QCursor(QtCore.Qt.OpenHandCursor)) def mouseMoveEvent(self, QMouseEvent): # 鼠标在按下左键的情况下移动时,根据坐标移动界面 if Qt.LeftButton and self._move_drag: self.move(QMouseEvent.globalPosition().toPoint() - self.m_Position) QMouseEvent.accept() def mouseReleaseEvent(self, QMouseEvent): # 鼠标按键释放时,取消移动 self._move_drag = False self.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor)) 最后，添加最大化、最小化和关闭按钮\n定义标题栏类，包括三个按钮及其图标。直接用我写的即可，已设置好样式。\nfrom PySide6 import QtCore from PySide6.QtGui import QIcon from PySide6.QtWidgets import QFrame, QHBoxLayout, QPushButton class CustomTitleBar(QFrame): def __init__(self, parent): super().__init__(parent) # 设置样式 self.setStyleSheet(\u0026#39;\u0026#39;\u0026#39; QFrame{ background-color: rgb(171, 176, 181); border-top-left-radius:10px; border-top-right-radius:10px; border-bottom-left-radius:0px; border-bottom-right-radius:0px; } QPushButton{ border: none; background-color: rgb(171, 176, 181); } QPushButton:pressed{ padding-left:3px; padding-top:3px; } QPushButton:hover{ padding-bottom:3px; } \u0026#39;\u0026#39;\u0026#39;) # 设置布局 layout = QHBoxLayout(self) layout.setSpacing(0) layout.setAlignment(QtCore.Qt.AlignRight) # 最小化按钮 btn_minimize = QPushButton(self) btn_minimize.setIcon(QIcon(\u0026#39;resource/icons/minus.png\u0026#39;)) btn_minimize.clicked.connect(self.parent().showMinimized) layout.addWidget(btn_minimize) # 最大化/恢复按钮 self.btn_maximize_restore = QPushButton(self) self.btn_maximize_restore.setIcon(QIcon(\u0026#39;resource/icons/maxmize.png\u0026#39;)) layout.addWidget(self.btn_maximize_restore) # 关闭按钮 btn_close = QPushButton(self) btn_close.setIcon(QIcon(\u0026#39;resource/icons/close.png\u0026#39;)) btn_close.clicked.connect(self.parent().close) layout.addWidget(btn_close) 在主窗口类中引用CustomTitleBar，创建对象并绑定槽函数，用于窗口的放大、缩小。\n# 添加状态栏 self.custom_title_bar = CustomTitleBar(self) self.custom_title_bar.btn_maximize_restore.clicked.connect(self.resize_win) # 槽函数 def resize_win(self): if self.isMaximized(): self.showNormal() self.custom_title_bar.btn_maximize_restore.setIcon( QtGui.QIcon(\u0026#39;resource/icons/maxmize.png\u0026#39;)) else: self.showMaximized() self.custom_title_bar.btn_maximize_restore.setIcon( QtGui.QIcon(\u0026#39;resource/icons/minisize.png\u0026#39;)) 其中，图标可以在阿里矢量图标库下载，直接搜索放大、缩小等，下载后的 png 图片存到对应文件夹即可。\n改进后的程序界面如下：\n侧边栏 侧边栏用于显示不同板块，在点击后切换到指定的页面。主要包括左侧的侧边栏以及右侧的页面。\n侧边栏类可以直接用我写的，已设置好样式：\nclass SideBar(QFrame): def __init__(self, parent): super().__init__(parent) # 设置样式 self.setStyleSheet(\u0026#39;\u0026#39;\u0026#39; QFrame{ background-color: rgb(221, 223, 226); } QListWidget { color: Black; background-color: rgb(221, 223, 226); } QListWidget::Item:hover { background: rgb(233, 234, 236); border-left: 3px solid rgb(76, 95, 107); } QListWidget::Item:selected { background: rgb(233, 234, 236); border-left: 3px solid rgb(76, 95, 107); } \u0026#39;\u0026#39;\u0026#39;) self.list_widget = QListWidget(self) self.list_widget.setFixedWidth(150) self.list_widget.setSpacing(5) layout = QVBoxLayout(self) layout.setSpacing(0) layout.setContentsMargins(1, 1, 0, 0) layout.addWidget(self.list_widget) # 添加item img_icon = QIcon(\u0026#39;resource/icons/img_improve.png\u0026#39;) self.img_item = QListWidgetItem(img_icon, \u0026#39;视觉提升\u0026#39;, self.list_widget) self.img_item.setSizeHint(QtCore.QSize(10, 60)) self.img_item.setTextAlignment(QtCore.Qt.AlignCenter) self.img_item.setSelected(True) red_icon = QIcon(\u0026#39;resource/icons/red.png\u0026#39;) self.red_item = QListWidgetItem(red_icon, \u0026#39;红外融合\u0026#39;, self.list_widget) self.red_item.setSizeHint(QtCore.QSize(10, 60)) self.red_item.setTextAlignment(QtCore.Qt.AlignCenter) 接着，添加右侧页面，我们使用QStackedWidget，并在其中添加多个不同的Widget对应不同的组件：\n# 添加右侧页面 self.stack_widget = QtWidgets.QStackedWidget(self.frame_1) # 添加窗口部件 self.widget_1 = QWidget() self.label_1 = QLabel(\u0026#34;视觉提升页面\u0026#34;) layout_1 = QtWidgets.QVBoxLayout(self.widget_1) layout_1.addWidget(self.label_1) self.widget_2 = QWidget() self.label_2 = QLabel(\u0026#34;红外融合页面\u0026#34;) layout_2 = QtWidgets.QVBoxLayout(self.widget_2) layout_2.addWidget(self.label_2) # 添加各个widget到stack_widget中 self.stack_widget.addWidget(self.widget_1) self.stack_widget.addWidget(self.widget_2) self.stack_widget.setCurrentIndex(0) 通过setCurrentIndex方法设置页面，0为widget_1，1为widget_2。最后，添加槽函数，在点击左侧侧边栏按钮时切换页面。\n# 主界面类中，引用侧边栏，并绑定槽函数 self.side_bar = SideBar(self.frame_1) self.side_bar.list_widget.itemClicked.connect(self.item_clicked) #槽函数 def item_clicked(self): item = self.side_bar.list_widget.selectedItems()[0] if item.text() == \u0026#39;视觉提升\u0026#39;: self.stack_widget.setCurrentIndex(0) elif item.text() == \u0026#39;红外融合\u0026#39;: self.stack_widget.setCurrentIndex(1) 效果如下：\n完整代码如下，其中from components import CustomTitleBar, SideBar的类上面代码已给出，直接创建文件复制进去即可：\nimport sys from PySide6 import QtGui, QtCore, QtWidgets from PySide6.QtWidgets import QApplication, QWidget, QLabel from qt_material import apply_stylesheet from PySide6.QtCore import Qt from components import CustomTitleBar, SideBar class MainWindow(QWidget): def __init__(self): super().__init__() self.init_ui() self._move_drag = False def init_ui(self): # 设置窗口标题、图标 self.setWindowTitle(\u0026#34;视觉提升\u0026#34;) self.setWindowIcon(QtGui.QIcon(\u0026#39;resource/icons/appicon.png\u0026#39;)) # 创建窗口类 self.frame = QtWidgets.QFrame(self) self.frame.setObjectName(\u0026#34;frame\u0026#34;) self.frame.setStyleSheet(\u0026#39;\u0026#39;\u0026#39; QFrame { border: 0px; } #frame{ background-color: rgb(242, 242, 242); border-radius:10px; } \u0026#39;\u0026#39;\u0026#39;) self.hLayout = QtWidgets.QHBoxLayout(self) self.hLayout.addWidget(self.frame) self.hLayout.setContentsMargins(0, 0, 0, 0) # 使frame完全填充界面 # 窗口的大小 self.resize(800, 600) # 添加状态栏 self.custom_title_bar = CustomTitleBar(self) self.custom_title_bar.btn_maximize_restore.clicked.connect(self.resize_win) # 状态栏下半部分的窗口，frame_1 self.frame_1 = QtWidgets.QFrame(self.frame) self.frame_1.setObjectName(\u0026#34;frame_1\u0026#34;) # 添加侧边栏 self.side_bar = SideBar(self.frame_1) self.side_bar.list_widget.itemClicked.connect(self.item_clicked) # 添加右侧页面 self.stack_widget = QtWidgets.QStackedWidget(self.frame_1) # 添加窗口部件 self.widget_1 = QWidget() self.label_1 = QLabel(\u0026#34;视觉提升界面\u0026#34;) layout_1 = QtWidgets.QVBoxLayout(self.widget_1) layout_1.addWidget(self.label_1) self.widget_2 = QWidget() self.label_2 = QLabel(\u0026#34;红外融合界面\u0026#34;) layout_2 = QtWidgets.QVBoxLayout(self.widget_2) layout_2.addWidget(self.label_2) # 添加各个widget到stack_widget中 self.stack_widget.addWidget(self.widget_1) self.stack_widget.addWidget(self.widget_2) self.stack_widget.setCurrentIndex(0) # 布局: frame中， 状态栏（custom_title_bar）与下面部分（frame_1） self.gLayout = QtWidgets.QGridLayout(self.frame) self.gLayout.addWidget(self.custom_title_bar, 0, 0, 1, 1) self.gLayout.addWidget(self.frame_1, 2, 0, 20, 1) self.gLayout.setSpacing(0) self.gLayout.setContentsMargins(0, 0, 0, 0) # 布局: frame_1中，侧边栏（side_bar）与右侧部分（stackedWidget） self.gLayout_1 = QtWidgets.QGridLayout(self.frame_1) self.gLayout_1.addWidget(self.side_bar, 0, 0, 1, 2) self.gLayout_1.addWidget(self.stack_widget, 0, 2, 1, 10) self.gLayout_1.setSpacing(0) self.gLayout_1.setContentsMargins(0, 0, 0, 0) # # 去边框 self.setWindowFlag(Qt.FramelessWindowHint) self.setAttribute(Qt.WA_TranslucentBackground) # ---移动功能--- def mousePressEvent(self, event): # 鼠标左键按下时获取鼠标坐标 if event.button() == Qt.LeftButton: self._move_drag = True self.m_Position = event.globalPosition().toPoint() - self.pos() event.accept() self.setCursor(QtGui.QCursor(QtCore.Qt.OpenHandCursor)) def mouseMoveEvent(self, QMouseEvent): # 鼠标在按下左键的情况下移动时,根据坐标移动界面 if Qt.LeftButton and self._move_drag: self.move(QMouseEvent.globalPosition().toPoint() - self.m_Position) QMouseEvent.accept() def mouseReleaseEvent(self, QMouseEvent): # 鼠标按键释放时,取消移动 self._move_drag = False self.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor)) def resize_win(self): if self.isMaximized(): self.showNormal() self.custom_title_bar.btn_maximize_restore.setIcon( QtGui.QIcon(\u0026#39;resource/icons/maxmize.png\u0026#39;)) self.side_bar.list_widget.setFixedWidth(150) else: self.showMaximized() self.custom_title_bar.btn_maximize_restore.setIcon( QtGui.QIcon(\u0026#39;resource/icons/minisize.png\u0026#39;)) self.side_bar.list_widget.setFixedWidth(250) def item_clicked(self): item = self.side_bar.list_widget.selectedItems()[0] if item.text() == \u0026#39;视觉提升\u0026#39;: self.stack_widget.setCurrentIndex(0) elif item.text() == \u0026#39;红外融合\u0026#39;: self.stack_widget.setCurrentIndex(1) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) w = MainWindow() w.show() # 设置主题色为蓝色 apply_stylesheet(app, theme=\u0026#39;light_blue_500.xml\u0026#39;) # 程序进行循环等待状态，用于持久显示 sys.exit(app.exec()) 至此，我们已经完成了一个基础的程序模板。后续开发可以基于这个模板上进行改造。\n结合模型实现可视化 接下来，我将以视觉提升板块为例，介绍如何通过界面进行模型推理及结果的输出，包括图片及视频的处理。\n界面设计 首先，我们添加以下模块：\n上部分：\n选择图片/视频按钮：点击后选择电脑上的某个文件 选择效果下拉框：对给定的模型，选择要应用的效果，包括去雨、去雾、弱光等 确定按钮：点击后，用选择的效果对图片进行优化 中间部分\n图片标签：显示原图与处理后的图片，进行对比 下部分：\n视频控件：3个按钮，对视频的暂停、前进和后退操作 界面如下：\n其中，上部分frame_up和下部分的frame_down直接添加组件+设置水平布局即可，代码如下：\n# 添加右侧页面 self.stack_widget = QtWidgets.QStackedWidget(self.frame_1) # 添加窗口部件 self.widget_1 = QWidget() self.frame_2 = QtWidgets.QFrame(self.widget_1) self.hLayout_1 = QtWidgets.QHBoxLayout(self.widget_1) self.hLayout_1.addWidget(self.frame_2) self.hLayout_1.setContentsMargins(0, 0, 0, 0) # 从上至下 3个frame # 1. frame_up self.frame_up = QtWidgets.QFrame(self.frame_2) self.choose_img_btn = QPushButton(\u0026#34;选择图片/视频\u0026#34;, self.frame_up) self.choose_img_btn.setMinimumSize(150, 50) self.pre_combobox_text = QLabel(\u0026#34;效果：\u0026#34;, self.frame_up) self.pre_combobox_text.setMinimumHeight(50) self.combobox = QComboBox(self.frame_up) self.combobox.addItem(\u0026#34;去雨\u0026#34;) self.combobox.addItem(\u0026#34;去雾\u0026#34;) self.combobox.addItem(\u0026#34;弱光\u0026#34;) self.combobox.setMinimumHeight(50) self.admit_btn = QPushButton(\u0026#34;确定\u0026#34;, self.frame_up) self.admit_btn.setMinimumHeight(50) # frame_up的布局 self.up_layout = QtWidgets.QHBoxLayout(self.frame_up) self.up_layout.addStretch(1) self.up_layout.addWidget(self.choose_img_btn) self.up_layout.addStretch(2) self.up_layout.addWidget(self.pre_combobox_text) self.up_layout.addWidget(self.combobox) self.up_layout.addStretch(1) self.up_layout.addWidget(self.admit_btn) self.up_layout.addStretch(1) # 3. frame down, 视频组件 self.frame_down = QtWidgets.QFrame(self.frame_2) # play \u0026amp; pause self.playButton = QtWidgets.QPushButton(self.frame_down) self.playButton.setIcon(QtGui.QIcon(\u0026#39;resource/icons/play.png\u0026#39;)) self.playButton.setIconSize(QtCore.QSize(12, 12)) self.playButton.setMaximumSize(QtCore.QSize(80, 30)) # left \u0026amp; right button self.leftButton = QtWidgets.QPushButton(self.frame_down) self.rightButton = QtWidgets.QPushButton(self.frame_down) self.leftButton.setIcon(QtGui.QIcon(\u0026#39;resource/icons/左箭头.png\u0026#39;)) self.leftButton.setIconSize(QtCore.QSize(19, 19)) self.rightButton.setIcon(QtGui.QIcon(\u0026#39;resource/icons/右箭头.png\u0026#39;)) self.rightButton.setIconSize(QtCore.QSize(19, 19)) self.leftButton.setMaximumSize(QtCore.QSize(50, 30)) self.rightButton.setMaximumSize(QtCore.QSize(50, 30)) # frame_down布局 self.layout_down_2 = QtWidgets.QHBoxLayout(self.frame_down) self.layout_down_2.addWidget(self.leftButton) self.layout_down_2.addWidget(self.playButton) self.layout_down_2.addWidget(self.rightButton) self.layout_down_2.setContentsMargins(0, 0, 0, 0) 中间部分frame_mid通过QSplitter实现两张图片的分割布局，拖动分割线时两侧图片等比例缩放，这里有两点需要注意：\n默认通过QPixmap设置左右两个QLabel的图片时，图片会拉伸至label的尺寸，导致图片显示不全或变形，因此我们在设置图片之前要先将其尺寸缩放到label的尺寸，具体代码如下\n# 设置图片路径 self.pre_imgpath = \u0026#39;resource/images/1.jpg\u0026#39; self.res_imgpath = \u0026#39;resource/images/2.jpg\u0026#39; # 根据label大小缩放图片 import cv2 def scaleimg(self): def showimg(label, img_path): img_src = cv2.imdecode(np.fromfile(img_path, dtype=np.uint8), -1) ih, iw, _ = img_src.shape w = label.geometry().width() h = label.geometry().height() # keep original aspect ratio if iw / w \u0026gt; ih / h: scal = w / iw nw = w nh = int(scal * ih) img_src_ = cv2.resize(img_src, (nw, nh)) else: scal = h / ih nw = int(scal * iw) nh = h img_src_ = cv2.resize(img_src, (nw, nh)) frame = cv2.cvtColor(img_src_, cv2.COLOR_BGR2RGB) img = QImage(frame.data, frame.shape[1], frame.shape[0], frame.shape[2] * frame.shape[1],QImage.Format_RGB888) label.setPixmap(QPixmap.fromImage(img)) # label3为左侧框，label4为右侧框 showimg(self.label_3, self.pre_imgpath) showimg(self.label_4, self.res_imgpath) 要实现移动分割线时，图片跟着缩放，要设置splitter的槽函数为scaleimg，这样在每次拖动时，都会重新计算label尺寸，缩放图片，完整代码如下：\n# 2. frame mid, 两张图片对比， 用QSplitter分割 self.frame_mid = QSplitter(self.frame_2) self.frame_mid.setStyleSheet(\u0026#34;QSplitter::handle {image:url(resource/images/splitter.svg);}\u0026#34;) self.frame_mid.setHandleWidth(20) self.frame_mid.setOrientation(Qt.Horizontal) self.label_3 = QLabel(self.frame_mid) self.label_3.setAlignment(Qt.AlignCenter) self.label_3.setMinimumSize(QSize(50, 50)) self.frame_mid.addWidget(self.label_3) self.label_4 = QLabel(self.frame_mid) self.label_4.setAlignment(Qt.AlignCenter) self.label_4.setMinimumSize(QSize(50, 50)) self.frame_mid.addWidget(self.label_4) # 绑定槽函数 self.frame_mid.splitterMoved.connect(self.scaleimg) 实现效果如下，方便更清晰观察生成后的效果图\n最后，对3个frame进行布局，按照 up:mid:down = 2:10:1的比例\n# 3个frame布局（up, mid, down） self.gLayout_2 = QtWidgets.QGridLayout(self.frame_2) self.gLayout_2.addWidget(self.frame_up, 0, 0, 2, 1) self.gLayout_2.addWidget(self.frame_mid, 2, 0, 10, 1) self.gLayout_2.addWidget(self.frame_down, 12, 0, 1, 1) self.gLayout_2.setSpacing(0) 视频播放 对视频的处理如下所示：\n获取视频文件地址-\u0026gt;对视频进行抽帧-\u0026gt;对抽帧后的图片进行推理-\u0026gt;显示处理后的图片-\u0026gt;利用定时器，实现视频播放\n我们==假设==已完成了视频抽帧与处理，且文件结构如下，其中origin显示抽帧后的图片集合，processed显示处理后的图片，具体如何实现将在下节说明。\n├─results │ ├─videos │ │ └─视频文件名 └─origin └─0000.png └─0001.png └─0002.png └─processed └─0000.png └─0001.png └─0002.png 在此基础上，本节介绍如何对两个文件夹中的图片进行播放，形成对比，实现的效果如下：\n实现原理就是设置一个多线程的定时器，每隔一段时间（fps）就执行一次next_img函数，next_img函数会把左右label的图片都切换成下一张。定时器的代码如下，用到了QThread类，想要执行的任务在run函数中实现，然后实例化对象后通过object_name.start()即可启动。\nfrom PySide6.QtCore import QThread, Signal, QMutex, QMutexLocker import time import os # 视频播放计时器 class VideoTimer(QThread): timeSignal = Signal(str) # 每隔1/frequent秒，切换到下一帧 def __init__(self, frequent=1): QThread.__init__(self) self.stopped = False self.frequent = frequent self.mutex = QMutex() def run(self): with QMutexLocker(self.mutex): self.stopped = False while True: if self.stopped: return self.timeSignal.emit(\u0026#34;1\u0026#34;) time.sleep(1 / self.frequent) def stop(self): with QMutexLocker(self.mutex): self.stopped = True def is_stopped(self): with QMutexLocker(self.mutex): return self.stopped 在VideoTimer中，我们定义了一个信号 timeSignal = Signal(str)，并每隔1/frequent秒发送一次“1”。在主界面类中，定义VideoTimer对象，并在每次接收到该信号时切换到下一帧。\n# 定义定时器对象，并绑定信号 self.timer = VideoTimer(frequent=10) self.timer.timeSignal.connect(self.show_video_images) # show_video_images函数在下文给出 # 初始化视频播放相关变量 STATUS_INIT = 0 STATUS_PLAYING = 1 STATUS_PAUSE = 2 self.origin_path = \u0026#39;\u0026#39; self.processed_path = \u0026#39;\u0026#39; self.index = 0 #当前播放的帧序号 self.status = self.STATUS_INIT 接着，定义以下函数：\n视频停止时的重置函数reset：停止计时器，重置播放器状态 播放状态切换函数switch_video：如果当前状态为播放，改为暂停；如果为暂停，改为播放 播放按钮图标切换函数icon_change：播放状态切换时，切换\u0026#x23ef;\u0026#xfe0f;图标 帧上下切换函数pre_img、next_img：切换至上一张/下一张帧 视频播放函数show_video_images：通过调用next_img，完成视频的播放 def reset(self): self.timer.stop() while not self.timer.is_stopped(): time.sleep(0.5) self.status = self.STATUS_INIT self.index = 0 self.icon_change(1) def switch_video(self): if self.origin_path == \u0026#39;\u0026#39; or self.processed_path == \u0026#39;\u0026#39;: return if self.status is self.STATUS_INIT: self.timer.start() self.icon_change(2) elif self.status is self.STATUS_PLAYING: self.timer.stop() self.icon_change(1) elif self.status is self.STATUS_PAUSE: self.timer.start() self.icon_change(2) self.status = (self.STATUS_PLAYING, self.STATUS_PAUSE, self.STATUS_PLAYING)[self.status] # 展示图片集，切换上下张 def pre_img(self): if self.processed_path == \u0026#39;\u0026#39; or self.index == 0: return self.index -= 1 left_img_path = self.origin_path + \u0026#39;{:04d}.png\u0026#39;.format(self.index) right_img_path = self.processed_path + \u0026#39;{:04d}.png\u0026#39;.format(self.index) if not os.path.isfile(left_img_path) or not os.path.isfile(right_img_path): time.sleep(1) print(\u0026#39;pre,\u0026#39;, right_img_path) self.pre_imgpath = left_img_path self.res_imgpath = right_img_path self.scaleimg() def next_img(self): if self.processed_path == \u0026#39;\u0026#39; or self.index == len(os.listdir(self.processed_path)) - 1: return self.index += 1 left_img_path = self.origin_path + \u0026#39;{:04d}.png\u0026#39;.format(self.index) right_img_path = self.processed_path + \u0026#39;{:04d}.png\u0026#39;.format(self.index) if not os.path.isfile(left_img_path) or not os.path.isfile(right_img_path): return print(\u0026#39;next,\u0026#39;, right_img_path) r_img = QImage(right_img_path) if r_img.size().width() == 0: self.switch_video() return self.pre_imgpath = left_img_path self.res_imgpath = right_img_path self.scaleimg() # 同时修改label_3、label_4的图片，完成视频播放 def show_video_images(self): if self.processed_path == \u0026#39;\u0026#39; or self.index == len(os.listdir(self.origin_path)) - 1: self.reset() # 播放进度赶上生成进度-\u0026gt;暂停 elif self.index == len(os.listdir(self.processed_path)) - 1: self.switch_video() else: self.next_img() 最后，我们将按钮和函数绑定，实现点击中间按钮切换播放/暂停，点击左右按钮切换上下帧\nself.playButton.clicked.connect(self.switch_video) self.leftButton.clicked.connect(self.pre_img) self.rightButton.clicked.connect(self.next_img) 模型推理 选择文件 首先通过QFileDialog选择要进行处理的图像或视频 判断文件是视频还是图片 如果是视频，通过多线程对视频进行抽帧，结果保存至/results/videos/文件名/origin 展示图像 其中多线程抽帧代码如下：\nfrom PySide6.QtCore import QThread, Signal, QMutex, QMutexLocker import os import cv2 # 视频抽帧线程 class Video2Img(QThread): def __init__(self, url): super().__init__() self.url = url # 创建保存文件夹 name = url.split(\u0026#39;/\u0026#39;)[-1].split(\u0026#39;.\u0026#39;)[0] self.save_path = f\u0026#39;results/videos/{name}/origin/\u0026#39; os.makedirs(self.save_path, exist_ok=True) def run(self): # 打开视频文件，参数为文件路径 cap = cv2.VideoCapture(self.url) # 获取视频帧率和总帧数 total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT)) # 定义抽帧间隔 interval = 5 # 循环读取视频帧 for i in range(total_frames): ret, frame = cap.read() if i % interval == 0: # 实现对每5帧进行抽取 save_img_path = os.path.join(self.save_path, \u0026#39;{:04d}.png\u0026#39;.format(int(i / interval))) cv2.imencode(\u0026#39;.png\u0026#39;, frame)[1].tofile(save_img_path) # 释放视频文件 cap.release() 如下所示，对文件名为night_1的视频，生成了对应的文件夹及抽帧结果\n选择文件部分总代码如下：\ndef choose_image(self): global path path, _ = QFileDialog.getOpenFileName(self, \u0026#39;选择图片或视频\u0026#39;, \u0026#39;C:\\\\\u0026#39;, \u0026#39;Image files(*.jpg *.jpeg *.png);;Video Files (*.mp4 *.avi)\u0026#39;) # 如果没选择文件 if path == \u0026#39;\u0026#39;: return # 如果当前有视频播放，停止 if self.status is self.STATUS_PLAYING: self.reset() # 修改label4为 “请选择效果” self.res_imgpath = \u0026#39;resource/images/2.jpg\u0026#39; # 判断是视频 or 图片 # 1.视频 type = path.split(\u0026#39;.\u0026#39;)[-1] if type == \u0026#39;mp4\u0026#39; or type == \u0026#39;avi\u0026#39;: # 如果是视频，展示控件 self.frame_down.show() # 开一个线程，对视频抽帧，结果保存在/results/videos/文件名/origin self.v2i = Video2Img(path) self.v2i.start() name = path.split(\u0026#39;/\u0026#39;)[-1].split(\u0026#39;.\u0026#39;)[0] self.origin_path = f\u0026#39;results/videos/{name}/origin/\u0026#39; self.processed_path = \u0026#39;\u0026#39; img_path = self.origin_path + \u0026#39;0000.png\u0026#39; self.timer.timeSignal.connect(self.show_video_images) self.status = self.STATUS_INIT while not os.path.isfile(img_path): time.sleep(0.5) # 2.图片 else: self.frame_down.hide() img_path = path self.pre_imgpath = img_path self.scaleimg() 最后，绑定按钮与槽函数：\nself.choose_img_btn.clicked.connect(self.choose_image) 推理得到结果 为避免推理时主界面卡顿，我们同样使用多线程进行模型推理：\nfrom PySide6.QtCore import QThread, Signal, QMutex, QMutexLocker import time import os import cv2 from lowlight.low_light import lowlight_res from dehaze.dhaze import dehaze_image from derain.derain import derain_res # 模型推理线程 class VisionImproved(QThread): def __init__(self, url, data, is_dir=False): super().__init__() self.url = url # 图片/文件夹地址 self.data = data # 增强类型 self.dir = is_dir # 是否为文件夹里的图片（视频） def run(self): # 获取图片 if self.data == \u0026#39;弱光\u0026#39;: lowlight_res(self.url, self.dir) if self.data == \u0026#39;去雾\u0026#39;: dehaze_image(self.url, self.dir) if self.data == \u0026#39;去雨\u0026#39;: derain_res(self.url, self.dir) # 释放视频文件 这里的lowlight、derain和dehaze代码我就不给出了，调用后要求在📂/results/videos/文件名/processed中生成结果\n接着，编写img_improve函数，对VisionImproved线程进行调用\ndef img_improve(self): # 获取下拉框中的值 data = self.combobox.currentText() dic = {\u0026#39;弱光\u0026#39;: \u0026#39;lowlight\u0026#39;, \u0026#39;去雾\u0026#39;: \u0026#39;dehaze\u0026#39;, \u0026#39;去雨\u0026#39;: \u0026#39;derain\u0026#39;} global path # 图片 or 视频 type = path.split(\u0026#39;.\u0026#39;)[-1] name = path.split(\u0026#39;/\u0026#39;)[-1].split(\u0026#39;.\u0026#39;)[0] if type == \u0026#39;mp4\u0026#39; or type == \u0026#39;avi\u0026#39;: # 创建保存文件夹 save_path = f\u0026#39;results/videos/{name}/processed/\u0026#39; self.processed_path = save_path os.makedirs(save_path, exist_ok=True) img_path = save_path + \u0026#39;0000.png\u0026#39; # 创建线程，用于模型推理 self.vision_improved = VisionImproved(f\u0026#39;results/videos/{name}/\u0026#39;, data, is_dir=True) else: save_path = f\u0026#39;results/img/{dic[data]}/\u0026#39; os.makedirs(save_path, exist_ok=True) img_path = save_path + name + \u0026#39;.png\u0026#39; self.vision_improved = VisionImproved(path, data) # 新开线程，用于模型推理 self.vision_improved.start() # 未生成，暂停1秒 while not os.path.isfile(img_path): time.sleep(1) self.res_imgpath = img_path self.scaleimg() 最后，绑定槽函数即可：\nself.admit_btn.clicked.connect(self.img_improve) 待开发 本程序只完成了初步的视频预测，改进部分如下：\n对图片的预测仍然是单张，后续看能否改为批量 每次选择效果后都需要重加载模型，浪费了一定时间。考虑把各个效果的模型整合到一个大类中，方便直接调用 视频播放的策略是：固定帧率，当播放进度超越生成进度时，自动暂停。后续考虑根据生成速度自动调节帧率 模型转成onnx，加快推理速度 增加进度条，显示生成进度 ","permalink":"https://iendi.github.io/en/posts/ai/pyside6/","summary":"利用pyside6对python程序进行快速上手开发，实现模型的部署，请先安装pyside6相关依赖： pip install pyside6 pip install qt-material Pyside6基础知识 窗口","title":"Pyside6"},{"content":"StringTable为字符串常量池，是运行时常量池的一部分，一般放String字符串对象\n+ 运算符 两个 \u0026quot; \u0026quot; 相加 String s3=\u0026#34;ab\u0026#34;; //[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;ab\u0026#34;] String s4=\u0026#34;a\u0026#34;+\u0026#34;b\u0026#34;; System.out.println(s3==s4);//true s4=\u0026quot;a\u0026quot;+\u0026quot;b\u0026quot;在编译时，会自动优化成\u0026quot;ab\u0026quot;，查找常量池，如果没有存入，如果有则直接返回该对象\n变量相加 String s1=\u0026#34;a\u0026#34;; String s2=\u0026#34;b\u0026#34;; //[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;] String s3=\u0026#34;ab\u0026#34;; String s5=s1+s2; System.out.println(s3==s5);//false s5运行时，调用new StringBuilder().append(\u0026quot;a\u0026quot;).append(\u0026quot;b\u0026quot;).toString()，实际上就是new String(\u0026quot;ab\u0026quot;)，创建实例对象，存在java堆中，而s3存在常量池中，故不相等\nfinal 变量相加 String s1=\u0026#34;a\u0026#34;; final String s2=\u0026#34;b\u0026#34;; //[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;] String s3=\u0026#34;ab\u0026#34;; String s5=\u0026#34;a\u0026#34;+s2; System.out.println(s3==s5);//true 这里s2被final修饰，在编译期就能被识别，然后情况同两个 \u0026quot; \u0026quot; 相加一样\nintern() 方法 // jdk 1.8 String s1=\u0026#34;a\u0026#34;; String s2=\u0026#34;b\u0026#34;; //[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;] String s5=s1+s2;//new String(\u0026#34;ab\u0026#34;) //为堆中对象 String s6=s5.intern(); System.out.println(s5==s6);//true intern()方法把对象放入字符串常量池，在jdk1.6和1.8中有不同的特性：\njdk 1.6：常量池中放入\u0026quot;ab\u0026quot;，但 s5 仍为堆对象 jdk 1.8：常量池中放入\u0026quot;ab\u0026quot;，同时 s5也为常量池对象 如果字符串池中已经存在，则直接返回该对象：\n// jdk 1.8 String s1=\u0026#34;a\u0026#34;; String s2=\u0026#34;b\u0026#34;; String s3=\u0026#34;ab\u0026#34;; //[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;ab\u0026#34;] String s5=s1+s2;//new String(\u0026#34;ab\u0026#34;) //为堆中对象 String s6=s5.intern(); System.out.println(s5==s6);//false 此时s5不做入池操作，仍为堆对象\n","permalink":"https://iendi.github.io/en/posts/tech/java--jvm/stringtable-%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/","summary":"StringTable为字符串常量池，是运行时常量池的一部分，一般放String字符串对象 + 运算符 两个 \u0026quot; \u0026quot; 相加 String s3=\u0026#34;ab\u0026#34;; //[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;ab\u0026#34;] String s4=\u0026#34;a\u0026#34;+\u0026#34;b\u0026#34;; System.out.println(s3==s4);//true s4=\u0026quot;","title":"StringTable 一些特性"},{"content":"便于理解字节码，程序如下：\npublic class TextClass { String name; Integer age; public TextClass(String name, Integer age) { this.name = name; this.age = age; } public void show(){ System.out.println(\u0026#34;Hello MotherFucker\u0026#34;); } } 编译后，用javap -verbose TextClass.class反编译，得到如下\nClassfile /C:/1/test/out/production/test/TextClass.class Last modified 2021-7-31; size 660 bytes MD5 checksum 9ab04c39930dc92a510f52caf49cfa0c Compiled from \u0026#34;TextClass.java\u0026#34; public class TextClass minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #8.#24 // java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V #2 = Fieldref #7.#25 // TextClass.name:Ljava/lang/String; #3 = Fieldref #7.#26 // TextClass.age:Ljava/lang/Integer; #4 = Fieldref #27.#28 // java/lang/System.out:Ljava/io/PrintStream; #5 = String #29 // Hello MotherFucker #6 = Methodref #30.#31 // java/io/PrintStream.println:(Ljava/lang/String;)V #7 = Class #32 // TextClass #8 = Class #33 // java/lang/Object #9 = Utf8 name #10 = Utf8 Ljava/lang/String; #11 = Utf8 age #12 = Utf8 Ljava/lang/Integer; #13 = Utf8 \u0026lt;init\u0026gt; #14 = Utf8 (Ljava/lang/String;Ljava/lang/Integer;)V #15 = Utf8 Code #16 = Utf8 LineNumberTable #17 = Utf8 LocalVariableTable #18 = Utf8 this #19 = Utf8 LTextClass; #20 = Utf8 show #21 = Utf8 ()V #22 = Utf8 SourceFile #23 = Utf8 TextClass.java #24 = NameAndType #13:#21 // \u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V #25 = NameAndType #9:#10 // name:Ljava/lang/String; #26 = NameAndType #11:#12 // age:Ljava/lang/Integer; #27 = Class #34 // java/lang/System #28 = NameAndType #35:#36 // out:Ljava/io/PrintStream; #29 = Utf8 Hello MotherFucker #30 = Class #37 // java/io/PrintStream #31 = NameAndType #38:#39 // println:(Ljava/lang/String;)V #32 = Utf8 TextClass #33 = Utf8 java/lang/Object #34 = Utf8 java/lang/System #35 = Utf8 out #36 = Utf8 Ljava/io/PrintStream; #37 = Utf8 java/io/PrintStream #38 = Utf8 println #39 = Utf8 (Ljava/lang/String;)V { java.lang.String name; descriptor: Ljava/lang/String; flags: java.lang.Integer age; descriptor: Ljava/lang/Integer; flags: public TextClass(java.lang.String, java.lang.Integer); descriptor: (Ljava/lang/String;Ljava/lang/Integer;)V flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=3 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V 4: aload_0 5: aload_1 6: putfield #2 // Field name:Ljava/lang/String; 9: aload_0 10: aload_2 11: putfield #3 // Field age:Ljava/lang/Integer; 14: return LineNumberTable: line 9: 0 line 10: 4 line 11: 9 line 12: 14 LocalVariableTable: Start Length Slot Name Signature 0 15 0 this LTextClass; 0 15 1 name Ljava/lang/String; 0 15 2 age Ljava/lang/Integer; public void show(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #5 // String Hello MotherFucker 5: invokevirtual #6 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 15: 0 line 16: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 this LTextClass; } SourceFile: \u0026#34;TextClass.java\u0026#34; ","permalink":"https://iendi.github.io/en/posts/tech/java--jvm/%E5%AD%97%E8%8A%82%E7%A0%81/","summary":"便于理解字节码，程序如下： public class TextClass { String name; Integer age; public TextClass(String name, Integer age) { this.name = name; this.age = age; } public void show(){ System.out.println(\u0026#34;Hello MotherFucker\u0026#34;); } } 编译后，用javap -verbose TextClass.class反编译","title":"字节码"},{"content":"关于我\n英文名: Kend 运动: 骑车 ","permalink":"https://iendi.github.io/en/about/","summary":"关于我 英文名: Kend 运动: 骑车","title":"🙋🏻‍♂️关于"},{"content":" 单个类验证\n通过JSR-303 验证框架加Hibernate Validator机制进行验证\n先引入依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-validator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.1.0.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 然后在📃springmvc-servlet.xml中添加相关配置\n\u0026lt;bean class=\u0026#34;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\u0026#34; id=\u0026#34;validatorFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;providerClass\u0026#34; value=\u0026#34;org.hibernate.validator.HibernateValidator\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;mvc:annotation-driven validator=\u0026#34;validatorFactoryBean\u0026#34;/\u0026gt; 定义实体类Student，加入验证注解\n@Data public class Student { @NotNull(message = \u0026#34;姓名不能为空\u0026#34;) String name; @NotNull @Min(18) @Max(30) Integer age; @Email(message = \u0026#34;邮箱格式错误\u0026#34;) String email; } jsp中：\n\u0026lt;form action=\u0026#34;/validate\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;学生姓名：\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;学生邮箱：\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;学生年龄：\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td colspan=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/form\u0026gt; Controller中，输出错误对象与信息\n@Controller public class MyController { @GetMapping(\u0026#34;/user\u0026#34;) public Object sayHello(){ return \u0026#34;hello\u0026#34;; } @RequestMapping(\u0026#34;/validate\u0026#34;) @ResponseBody public Map\u0026lt;String,Object\u0026gt; validate( @Validated Student student, BindingResult errors) { List\u0026lt;ObjectError\u0026gt; oes = errors.getAllErrors(); for (ObjectError oe : oes) { String key, msg; if (oe instanceof FieldError) { FieldError fe = (FieldError) oe; //获取错误验证字段名 //如name,age,email key = fe.getField(); } else { //对象名，person key = oe.getObjectName(); } msg = oe.getDefaultMessage(); System.out.println(key+\u0026#34;:\u0026#34;+msg); } return null; } } 输出：\nemail:邮箱格式错误 age:最大不能超过30 分组校验\n首先定义两个空接口validGroup1、validGroup2，在校验注解上添加\n@Data public class Student { @NotNull(message = \u0026#34;姓名不能为空\u0026#34;,groups = validGroup1.class) String name; @NotNull @Min(18) @Max(30) Integer age; @Email(message = \u0026#34;邮箱格式错误\u0026#34;,groups = validGroup2.class) String email; } 然后验证时加上要验证的组即可：\n@Controller public class MyController { @RequestMapping(\u0026#34;/validate\u0026#34;) @ResponseBody public Map\u0026lt;String,Object\u0026gt; validate( @Validated(validGroup1.class) Person person, BindingResult errors) {} 常见的校验注解\n@Null、@NotNull：必须为空/不为空 @AssertTrue、@AssertFalse：必须为True/False Min(value)、Max(value)：为数字，其最大/最小值 DecimalMin(value)、DecimalMax(value)：同上，但是接受BigDecimal Size(max=, min=)：元素大小在范围内 @Past、@Future：：注解的日期必须是过去/将来的 @Email：必须为邮箱格式 @Pattern(regex=,flag=)：必须符合指定的正则表达式 @NotEmpty：字符串非空 @Length(min= ,max= )：字符串长度范围 ","permalink":"https://iendi.github.io/en/posts/tech/spring-mvc/05.-%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81/","summary":"单个类验证 通过JSR-303 验证框架加Hibernate Validator机制进行验证 先引入依赖： \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-validator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.1.0.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 然后在📃springmvc-se","title":"05. 数据验证"},{"content":"文件上传 文件上传通过MultipartResolver接口，有两个实现类，分别为StandardServletMultipartResolver和CommonsMultipartResolver，由于CommonsMultipartResolver要引入第三方依赖包，而前者只要使用Servlet API，故多使用StandardServletMultipartResolver，下面介绍用Spring MVC和Spring Boot配置的两种方式\n通过Spring MVC配置 配置\n在📃springmvc-servlet.xml中，加入bean，注意这里的id必须为multipartResolver\n\u0026lt;bean class=\u0026#34;org.springframework.web.multipart.support.StandardServletMultipartResolver\u0026#34; id=\u0026#34;multipartResolver\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; 然后在📃web.xml中，配置multipart-config，限制文件大小等\n\u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:spring-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;multipart-config\u0026gt; \u0026lt;!--文件保存的临时目录，这个目录系统不会主动创建，当超过内存保存文件最大值后创建--\u0026gt; \u0026lt;location\u0026gt;E:\\\\temp\u0026lt;/location\u0026gt; \u0026lt;!--上传的单个文件大小--\u0026gt; \u0026lt;max-file-size\u0026gt;1048576\u0026lt;/max-file-size\u0026gt; \u0026lt;!--上传的总文件大小--\u0026gt; \u0026lt;max-request-size\u0026gt;1048576\u0026lt;/max-request-size\u0026gt; \u0026lt;!--这个就是内存中保存的文件最大大小--\u0026gt; \u0026lt;file-size-threshold\u0026gt;4096\u0026lt;/file-size-threshold\u0026gt; \u0026lt;/multipart-config\u0026gt; \u0026lt;/servlet\u0026gt; 测试\n创建jsp页面，上传方式为post ，enctype属性有如下几种形式：\napplication/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。 multipart/form-data：这种编码方式会以==二进制流==的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。 text/plain：除了把空格转换为 \u0026ldquo;+\u0026rdquo; 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。 \u0026lt;form action=\u0026#34;/upload\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;上传\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; Controller类，对传入的图片文件，完成如下操作：\n在原文件名前加上UUID，防止文件名冲突 将文件储存在📂webapp/img/下，并返回文件地址 为保证能访问静态资源，在📃springmvc-servlet.xml中加入 \u0026lt;mvc:default-servlet-handler /\u0026gt;，让Spring MVC默认不处理静态资源 @Controller public class MyController { @GetMapping(\u0026#34;/user\u0026#34;) public Object sayHello(){ return \u0026#34;hello\u0026#34;; } @RequestMapping(\u0026#34;/upload\u0026#34;) @ResponseBody public String upload(MultipartFile file, HttpServletRequest req) { //获取Servlet上下文，用于读取全局配置参数 ServletContext context = req.getServletContext(); String realPath = context.getRealPath(\u0026#34;/img\u0026#34;); File folder = new File(realPath); if (!folder.exists()) folder.mkdirs(); //获取文件名 String oldName = file.getOriginalFilename(); //UUID做新文件名，防止冲突 String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(\u0026#34;.\u0026#34;)); try { //transferTo保存文件 file.transferTo(new File(folder, newName)); //getScheme返回当前协议（HTTP/HTTPS），getServerName返回地址，getServerPort返回端口号 String url = req.getScheme() + \u0026#34;://\u0026#34; + req.getServerName() + \u0026#34;:\u0026#34; + req.getServerPort() + \u0026#34;/img/\u0026#34; + newName; return url; } catch (IOException e) { e.printStackTrace(); } return \u0026#34;failed\u0026#34;; } } 通过 Spring Boot 配置 SpringBoot 自动引入StandardServletMultipartResolver，不用进行注册\n配置在📃application.properties中\n# 是否启用 Spring MVC 多分部上传 spring.servlet.multipart.enabled=true # 文件写入磁盘的最大大小，单位 KB或 MB spring.servlet.multipart.file-size-threshold=0 # 配置最大上传单个文件大小 spring.servlet.multipart.max-file-size = 20MB # 所有文件最大大小 spring.servlet.multipart.max-request-size=200MB # 指定默认上传的文件夹 spring.servlet.multipart.location= # 是否延迟多部件文件请求 spring.servlet.multipart.resolve-lazily=false 多文件上传 相同key\njsp如下，多了个multiple属性\n\u0026lt;form action=\u0026#34;/upload\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;files\u0026#34; multiple\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;上传\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 接收时改为数组即可：\n@Controller public class MyController { @RequestMapping(\u0026#34;/upload\u0026#34;) @ResponseBody public String upload(MultipartFile[] file, HttpServletRequest req) {} } 不同key\njsp如下：\n\u0026lt;form action=\u0026#34;/upload\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file1\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file2\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;上传\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 接收时定义多个变量即可：\n@Controller public class MyController { @RequestMapping(\u0026#34;/upload\u0026#34;) @ResponseBody public String upload(MultipartFile file1, MultipartFile file2, HttpServletRequest req) {} } 文件下载 @RequestMapping(value=\u0026#34;/download\u0026#34;) public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception{ //要下载的图片地址 String path = request.getServletContext().getRealPath(\u0026#34;/img\u0026#34;); String fileName = \u0026#34;82f1ba1c-c94c-48d3-8291-e3a519d2c418.jpg\u0026#34;; //1、设置response 响应头 response.reset(); //设置页面不缓存,清空buffer response.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); //字符编码 response.setContentType(\u0026#34;multipart/form-data\u0026#34;); //二进制传输数据 //设置响应头 response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;fileName=\u0026#34;+URLEncoder.encode(fileName, \u0026#34;UTF-8\u0026#34;)); File file = new File(path,fileName); //2、 读取文件--输入流 InputStream input=new FileInputStream(file); //3、 写出文件--输出流 OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作 while((index= input.read(buff))!= -1){ out.write(buff, 0, index); out.flush(); } out.close(); input.close(); return null; } 前端：\n\u0026lt;a href=\u0026#34;/download\u0026#34;\u0026gt;点击下载\u0026lt;/a\u0026gt; ","permalink":"https://iendi.github.io/en/posts/tech/spring-mvc/04.-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/","summary":"文件上传 文件上传通过MultipartResolver接口，有两个实现类，分别为StandardServletMultipartResolv","title":"04. 文件上传与下载"},{"content":"获取参数 1. 无注解下获取参数 无注解下，要求参数名与HTTP请求的参数名一致\n@Controller public class MyController { @RequestMapping(\u0026#34;/hello\u0026#34;) @ResponseBody public Object sayHello(String name,Integer age,String str){ Map\u0026lt;String,Integer\u0026gt; map=new HashMap\u0026lt;\u0026gt;(); map.put(name,age); sout(str); return map; } 请求URL：http://localhost:8080/hello?name=LiHua\u0026amp;age=20即可返回，由于str默认为空，因此没传入也可以\n2. 用@RequestParam获取 若传入参数与URL中不同，如http://localhost:8080/hello?minzi=LiHua\u0026amp;nianling=20\n@Controller public class MyController { @RequestMapping(\u0026#34;/hello\u0026#34;) @ResponseBody public Object sayHello( @RequestParam(\u0026#34;minzi\u0026#34;) String name, @RequestParam(\u0026#34;nianling\u0026#34;) Integer age, @RequestParam(value=\u0026#34;s\u0026#34;,required=false) String str){} } 注意str参数中加了required=false，允许没传入，否则会报错\n3. 获取JSON 通过@RequestBody接收前端传入的JSON参数\n@Controller public class MyController { @RequestMapping(\u0026#34;/hello\u0026#34;) @ResponseBody public Object sayHello(@RequestBody User user){} } 若返回JSON，使用 @ResponseBody\n4. 通过URL传递 如果URL为RestFul风格，如http://localhost:8080/user/#id/#age，可使用@PathVariable\n@Controller public class MyController { @GetMapping(\u0026#34;/user/{name}/{age}\u0026#34;) @ResponseBody public Object sayHello(@PathVariable(\u0026#34;name\u0026#34;) String name, @PathVariable(\u0026#34;age\u0026#34;) Integer age){ Map\u0026lt;String,Integer\u0026gt; map=new HashMap\u0026lt;\u0026gt;(); map.put(name,age); return map; } } 5. 传递格式化参数 通过DateTimeFormat和NumberFormat进行转换\n先在jsp中设置时间和金额，用于传递\n\u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;${pageContext.request.contextPath}/commit/\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;请输入日期（yyyy-MM-dd）\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;date\u0026#34; value=\u0026#34;2021-07-16\u0026#34; /\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;请输入金额（#,###.##）\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;number\u0026#34; value=\u0026#34;12,345.678\u0026#34;/\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td colspan=\u0026#34;2\u0026#34; align=\u0026#34;right\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; Controller中对传递的参数进行格式化接收：\n@Controller public class MyController { @GetMapping(\u0026#34;/user/\u0026#34;) public Object sayHello(){ return \u0026#34;hello\u0026#34;; } @PostMapping(\u0026#34;/commit/\u0026#34;) @ResponseBody public Object format( @DateTimeFormat(iso= DateTimeFormat.ISO.DATE) Date date, @NumberFormat(pattern = \u0026#34;#,###.###\u0026#34;) Double number)throws ParseException { Map\u0026lt;String,Object\u0026gt; map=new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;date\u0026#34;,date); map.put(\u0026#34;number\u0026#34;,number); return map; } } 提交后结果：{\u0026ldquo;date\u0026rdquo;:1626393600000,\u0026ldquo;number\u0026rdquo;:12345.678}\n**注意：**通过post传入中文时，会发生乱码，在web.xml中加入\n\u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;forceRequestEncoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;true\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;forceResponseEncoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;true\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 返回参数 1. 返回 ModelAndView 一般如果不是前后端分离，通常会返回ModelAndView类\n@Controller @RequestMapping(\u0026#34;/user\u0026#34;) public class HelloController { @RequestMapping(\u0026#34;/hello\u0026#34;) public ModelAndView hello() { //视图名，通过视图解析器定位到视图 ModelAndView mv = new ModelAndView(\u0026#34;hello\u0026#34;); //往视图中添加属性 mv.addObject(\u0026#34;username\u0026#34;, \u0026#34;javaboy\u0026#34;); return mv; } } 2. 通过Servlet API 确保pom文件中添加了Servlet依赖\n//服务端跳转 @RequestMapping(\u0026#34;/hello2\u0026#34;) public void hello2(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setAttribute(\u0026#34;msg\u0026#34;,\u0026#34;hello\u0026#34;); req.getRequestDispatcher(\u0026#34;/jsp/hello.jsp\u0026#34;).forward(req,resp);//服务器端跳转 } //重定向 @RequestMapping(\u0026#34;/hello3\u0026#34;) public void hello3(HttpServletRequest req, HttpServletResponse resp) throws IOException { resp.sendRedirect(\u0026#34;/hello.jsp\u0026#34;); } //返回字符串或JSON @RequestMapping(\u0026#34;/hello4\u0026#34;) public void hello4(HttpServletRequest req, HttpServletResponse resp) throws IOException { resp.setContentType(\u0026#34;text/html;charset=utf-8\u0026#34;); PrintWriter out = resp.getWriter(); out.write(\u0026#34;hello javaboy!\u0026#34;); out.flush(); out.close(); } 3. 通过Spring MVC //返回视图名 @RequestMapping(\u0026#34;/hello5\u0026#34;) public String hello5(Model model) { model.addAttribute(\u0026#34;username\u0026#34;, \u0026#34;javaboy\u0026#34;);//这是数据模型 return \u0026#34;hello\u0026#34;;//表示去查找一个名为 hello 的视图 } //服务端跳转 @RequestMapping(\u0026#34;/hello5\u0026#34;) public String hello5() { return \u0026#34;forward:/jsp/hello.jsp\u0026#34;; } //重定向 @RequestMapping(\u0026#34;/hello5\u0026#34;) public String hello5() { return \u0026#34;redirect:/user/hello\u0026#34;; } 注意：用@ResponseBody返回中文字符串时，可能会乱码，在produces中加上utf-8即可\n@RequestMapping(value = \u0026#34;/hello5\u0026#34;,produces = \u0026#34;text/html;charset=utf-8\u0026#34;) @ResponseBody public String hello5() { return \u0026#34;Java 语言程序设计\u0026#34;; } ","permalink":"https://iendi.github.io/en/posts/tech/spring-mvc/02.-%E6%8E%A7%E5%88%B6%E5%99%A8%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0/","summary":"获取参数 1. 无注解下获取参数 无注解下，要求参数名与HTTP请求的参数名一致 @Controller public class MyController { @RequestMapping(\u0026#34;/hello\u0026#34;) @ResponseBody public Object sayHello(String name,Integer age,String str){ Map\u0026lt;String,Integer\u0026gt; map=new HashMap\u0026lt;\u0026gt;(); map.put(name,age); sout(str); return map; } 请求URL：http://","title":"02. 控制器获取参数及返回"},{"content":"对前端传来的参数，绑定至已有对象中\n通过表单post数据，首先先在web.xml中加入filter，防止中文乱码\n\u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;forceRequestEncoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;true\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;forceResponseEncoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;true\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 1. 传入基本数据类型 Integer、Boolean、String 等简单数据类型\n先创建hello.jsp，传入基本数据类型\n\u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;/commit\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;名字\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;年龄\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;age\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;性别 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;true\u0026#34;\u0026gt;男\u0026lt;/input\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;false\u0026#34;\u0026gt;女\u0026lt;/input\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td colspan=\u0026#34;2\u0026#34; align=\u0026#34;right\u0026#34;\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; Controller中接收\n@Controller public class MyController { @GetMapping(\u0026#34;/user\u0026#34;) public Object sayHello(){ return \u0026#34;hello\u0026#34;; } @PostMapping(\u0026#34;/commit\u0026#34;) @ResponseBody public Object format(String name,Integer age,Boolean sex){ JSONObject jsonObject=new JSONObject(); jsonObject.put(\u0026#34;姓名\u0026#34;,name); jsonObject.put(\u0026#34;年龄\u0026#34;,age); jsonObject.put(\u0026#34;性别\u0026#34;,sex?\u0026#34;男\u0026#34;:\u0026#34;女\u0026#34;); return jsonObject; } } 测试结果\n2. 传入实体类 创建Student类，还是用hello.jsp传入，只要名字对应相等，就可以传入\n@Data public class Person { String name; Integer age; Boolean sex; } Controller类\n@Controller public class MyController { @GetMapping(\u0026#34;/user\u0026#34;) public Object sayHello(){ return \u0026#34;hello\u0026#34;; } @PostMapping(\u0026#34;/commit\u0026#34;) @ResponseBody public void format(Person person){ System.out.println(person); } } 输出：Person(name=admin, age=23, sex=false)\n如果实体类中还有其他类，如：\n@Data public class Person { String name; Integer age; Boolean sex; Money money; } //其中Money类： @Data public class Money { String name; Integer num; } 只要在jsp中添加为money.xx即可\n\u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;/commit\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;名字\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;年龄\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;age\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;性别 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;true\u0026#34;\u0026gt;男\u0026lt;/input\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;false\u0026#34;\u0026gt;女\u0026lt;/input\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;%--Money类--%\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;货币类型\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;money.name\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;余额\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;money.num\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td colspan=\u0026#34;2\u0026#34; align=\u0026#34;right\u0026#34;\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; 3. 自定义参数类型转换 对Integer、String、Double等类，Spring MVC自身的HttpMessageConverter就能进行转换，但如果想把String类转换成Person类，如传入字符串“Lihua-22-false”，转换成Person类型，则要定制自己的转换器\n定制转换器，首先要实现Converter\u0026lt;S,T\u0026gt;接口，S表示源类型，T为目标类型\n@Component public class StringToPerson implements Converter\u0026lt;String,Person\u0026gt; { @Override public Person convert(String source) { String[] str=source.split(\u0026#34;-\u0026#34;); String name=str[0]; Integer age=Integer.parseInt(str[1]); Boolean sex=Boolean.parseBoolean(str[2]); return new Person(name,age,sex); } } 在mvc配置文件springmvc-servlet.xml中注册转换器\n\u0026lt;mvc:annotation-driven conversion-service=\u0026#34;conversionService\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.format.support.FormattingConversionServiceFactoryBean\u0026#34; id=\u0026#34;conversionService\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;converters\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;ref bean=\u0026#34;stringToPerson\u0026#34;/\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; Controller如下：\n@Controller public class MyController { @GetMapping(\u0026#34;/person\u0026#34;) @ResponseBody public void getPerson(Person person){ System.out.println(person); } } 浏览器请求http://localhost:8080/person?person=Lihua-22-false，输出：\nPerson(name=Lihua, age=22, sex=false)，转换成功\n**注意：**如果用SpringBoot，可以省去注册步骤，会自动把实现了Converter接口的Bean注册到ConverterService对象中\n4. 传入数组 如果前端传入多选数据：\n\u0026lt;form action=\u0026#34;/commit\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;名字\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;年龄\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;age\u0026#34; value=\u0026#34;\u0026#34; /\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;性别 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;true\u0026#34;\u0026gt;男\u0026lt;/input\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;false\u0026#34;\u0026gt;女\u0026lt;/input\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;兴趣爱好：\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;favorites\u0026#34; value=\u0026#34;足球\u0026#34;\u0026gt;足球 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;favorites\u0026#34; value=\u0026#34;篮球\u0026#34;\u0026gt;篮球 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;favorites\u0026#34; value=\u0026#34;乒乓球\u0026#34;\u0026gt;乒乓球 \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td colspan=\u0026#34;2\u0026#34; align=\u0026#34;right\u0026#34;\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/form\u0026gt; 可以用String数组接收，注意不能使用List接收\nController类：\n@Controller public class MyController { @GetMapping(\u0026#34;/user\u0026#34;) public Object sayHello(){ return \u0026#34;hello\u0026#34;; } @PostMapping(\u0026#34;/commit\u0026#34;) @ResponseBody public void format(Person person,String[] favorites){ System.out.println(person); System.out.println(\u0026#34;兴趣爱好:\u0026#34;); for (String favorite : favorites) { System.out.println(favorite); } } } 输出：\nPerson(name=admin, age=23, sex=true) 兴趣爱好: 足球 篮球 ","permalink":"https://iendi.github.io/en/posts/tech/spring-mvc/03.-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/","summary":"对前端传来的参数，绑定至已有对象中 通过表单post数据，首先先在web.xml中加入filter，防止中文乱码 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;forceRequestEncoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;true\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;forceResponseEncoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;true\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt;","title":"03. 参数绑定"},{"content":"MVC 全流程 通过@RequestMapping注解，将控制器(Controller) 扫描进HandleMapping DispatcherServlet接收HTTP请求，通过HandleMapping寻找控制器，HandleMapping返回HandlerExecutionChain对象 HandlerExecutionChain中包括日志、处理器、拦截器等 通过HandlerAdapter接口定义的实现类(常用HttpRequestHandlerAdapter) 执行HandlerExecutionChain中的处理器对象 处理器对象通过业务层，DAO层等获取数据，放入模型并返回模型和视图对象（ModelAndView），比如常用的Controller-\u0026gt;Service-\u0026gt;Repository-\u0026gt;Mysql ViewResolver解析视图地址，最后视图被渲染出来 创建一个简单的Spring MVC应用 先用maven，创建一个web项目，添加依赖：\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet.jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 修改web.xml，添加mvc相关配置\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!--1.注册servlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;SpringMVC\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!-- 启动顺序，数字越小，启动越早 --\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!--所有请求都会被springmvc拦截 --\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;SpringMVC\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 📂resources中添加springmvc-servlet.xml，注意 \u0026lt;mvc:annotation-driven /\u0026gt;作用：\n为了使@RequestMapping注解生效，必须向上下文中注册DefaultAnnotationHandlerMapping和一个AnnotationMethodHandlerAdapter实例，annotation-driven配置自动完成上述两个实例注入 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.xu.mvc.Controller\u0026#34;/\u0026gt; \u0026lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --\u0026gt; \u0026lt;mvc:annotation-driven /\u0026gt; \u0026lt;!-- 视图解析器 --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;!-- 前缀 --\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/jsp/\u0026#34; /\u0026gt; \u0026lt;!-- 后缀 --\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 添加Controller\n@Controller public class MyController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String sayHello(Model model){ //向模型中添加属性name的值，可以在JSP页面中取出并渲染 model.addAttribute(\u0026#34;name\u0026#34;,\u0026#34;MotherFucker\u0026#34;); //jsp/hello.jsp return \u0026#34;hello\u0026#34;; } } 在📂webapp/jsp下添加hello.jsp\n\u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Try 1 Try\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello ${name}!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 启动tomcat，即可看到结果\n","permalink":"https://iendi.github.io/en/posts/tech/spring-mvc/01.-spring-mvc%E5%85%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/","summary":"MVC 全流程 通过@RequestMapping注解，将控制器(Controller) 扫描进HandleMapping DispatcherServ","title":"01. Spring MVC全流程及简单配置"},{"content":"经典例题：\n76. 最小覆盖子串\n给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \u0026quot;\u0026quot; 。\n获取t中各字符的个数，储存到need数组，获取t中不同字符的个数，存至charNum 增加right，直到[left,right)中包含t中所有字符 如果增加的字符在need数组中，window数组的相应字符数加一 当window[c]==need[c]，即window数组中c字符的数量达到要求，match++ 当match匹配数与t中不同字符的个数charNum相同时，缩小窗口，增加left，直至字符不再符合要求 left 不在need数组中，直接left++ 如果在数组中，判断是否到了最小值（need[left]==window[left]），到了就match\u0026ndash;，退出循环，否则window[left]--，继续left++缩小窗口 设置一个minLength储存当前窗口的长度，begin和end储存索引，right继续向右移寻找下一个满足窗口，直到right\u0026gt;=s.length public String minWindow(String s,String t){ //window数组，记录当前窗口中匹配的字符个数 int[] window = new int[256]; int[] need = new int[256]; //1. for (char c : t.toCharArray()) { need[c]++; } int charNum = 0; for (int n : need) { if (n \u0026gt; 0) { charNum++; } } //2. int left=0,right=0,begin=0,end=0,match=0; int minLength = Integer.MAX_VALUE; while(right\u0026lt;s.length()){ char c = s.charAt(right); if(need[c]!=0) { window[c]++; if(window[c]==need[c]) match++; } right++; //3. while(match==charNum){ //4.判断是否为最小窗口 if(right-left\u0026lt;minLength){ minLength=right-left; end=right; begin=left; } char leftChar=s.charAt(left); if(need[leftChar]!=0){ if(window[leftChar]==need[leftChar]){ match--; } window[leftChar]--; } left++; } } return minLength==charNum; } 438. 找到字符串中所有字母异位词\n给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引\n也是一样滑动窗口，在每一次left收缩到最小时，判断right-left长度是否与t.length()一样 public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { List\u0026lt;Integer\u0026gt; ans=new ArrayList\u0026lt;\u0026gt;(); int[] need=new int[256]; int[] window=new int[256]; for(char c:p.toCharArray()){ need[c]++; } int charNum=0; for(int n:need){ if(n\u0026gt;0) charNum++; } int left=0,right=0,match=0; while(right\u0026lt;s.length()){ char c=s.charAt(right); if(need[c]!=0){ window[c]++; if(window[c]==need[c]) match++; } right++; while(match==charNum){ char leftChar=s.charAt(left); if(need[leftChar]!=0){ if(window[leftChar]==need[leftChar]) { match--; //判断，如果和长度相等，加入 if(right-left==p.length()) ans.add(left); } window[leftChar]--; } left++; } } return ans; } 3. 无重复字符的最长子串\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度\n不用need和charNum，只要判断window[c]是否大于1，若大于，收缩left即可 public int lengthOfLongestSubstring(String s) { int[] window=new int[256]; int len=0,left=0,right=0; while(right\u0026lt;s.length()){ char c=s.charAt(right); window[c]++; while(window[c]\u0026gt;1){ char leftChar=s.charAt(left); window[leftChar]--; left++; } len=Math.max(len,right-left+1); right++; } return len; } ","permalink":"https://iendi.github.io/en/posts/lc/%E5%85%B6%E4%BB%96/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","summary":"经典例题： 76. 最小覆盖子串 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串","title":"滑动窗口"},{"content":"解决 \u0026ldquo;next greater number\u0026rdquo; 问题\n496. 下一个更大元素 I 给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。\n请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。\nnums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。\n思路：\n先对nums2从尾到头，通过单调栈寻找下一个更大数，存入HashMap nums1直接通过HashMap提取，返回答案 重点是通过单调栈寻找下一个更大数 class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { int[] ans=new int[nums1.length]; HashMap\u0026lt;Integer,Integer\u0026gt; num=build(nums2); for(int i=0;i\u0026lt;nums1.length;i++){ ans[i]=num.get(nums1[i]); } return ans; } public HashMap\u0026lt;Integer,Integer\u0026gt; build(int[] nums2){ Stack\u0026lt;Integer\u0026gt; stack=new Stack\u0026lt;\u0026gt;(); HashMap\u0026lt;Integer,Integer\u0026gt; ans=new HashMap\u0026lt;\u0026gt;(); //nums2从尾到头 for(int i=nums2.length-1;i\u0026gt;=0;i--){ while(!stack.empty()\u0026amp;\u0026amp;nums2[i]\u0026gt;=stack.peek()){ stack.pop(); } int v=stack.empty()?-1:stack.peek(); stack.push(nums2[i]);//进栈，进行后面的大小判定 ans.put(nums2[i],v); } return ans; } } 503. 下一个更大元素 II 环形数组\n思路：\n把原数组“复制”一份，如原来[1,2,1]——\u0026gt;[1,2,1,1,2,1]，再对新数组通过单调栈处理即可 通过==取余==操作，达到不增长数组空间 class Solution { public int[] nextGreaterElements(int[] nums) { int len=nums.length; int[] ans=new int[len]; Stack\u0026lt;Integer\u0026gt; s=new Stack\u0026lt;\u0026gt;(); //nums数组变为原来的两倍 for(int i=2*len-1;i\u0026gt;=0;i--){ while(!s.empty()\u0026amp;\u0026amp;nums[i%len]\u0026gt;=s.peek()){ s.pop(); } //ans最终会被赋两趟值，[len+1,len+2..,2len-1]被[1,2,..len-1]覆盖 ans[i%len]=s.empty()?-1:s.peek(); s.push(nums[i%len]); } return ans; } } 739. 每日温度 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替\n例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]\n思路：\n也是单调栈，不过存入栈的是索引 class Solution { public int[] dailyTemperatures(int[] temperatures) { Stack\u0026lt;Integer\u0026gt; s=new Stack\u0026lt;\u0026gt;(); int[] ans=new int[temperatures.length]; for(int i=temperatures.length-1;i\u0026gt;=0;i--){ while(!s.empty()\u0026amp;\u0026amp;temperatures[i]\u0026gt;=temperatures[s.peek()]){ s.pop(); } ans[i]=s.empty()?0:s.peek()-i; s.push(i); } return ans; } } 84. 柱状图中最大的矩形\n(还不会)\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1\n求在该柱状图中，能够勾勒出来的矩形的最大面积\n思路：\n对数组遍历，每个点的值为高，往左\u0026amp;往右直到遇到比当前值小的点，为宽\n数组两端个加个0，便于判断，通过System的静态复制方法\nint[] tmp = new int[heights.length + 2]; System.arraycopy(heights, 0, tmp, 1, heights.length); //temp中未赋值的[0]和[heights.length+1]初始化为0 ","permalink":"https://iendi.github.io/en/posts/lc/%E5%8D%95%E8%B0%83%E6%A0%88/84/","summary":"解决 \u0026ldquo;next greater number\u0026rdquo; 问题 496. 下一个更大元素 I 给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。 请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。 nums1","title":"单调栈"},{"content":" 切面 Spring 中的 Aop 的通知类型有 5 种：\n前置通知 后置通知 异常通知 返回通知 环绕通知 首先，在项目中，引入 Spring 依赖（引入 Aop 相关的依赖）：\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.9.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjrt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 接下来，定义切点，这里介绍两种切点的定义方式：\n使用自定义注解 使用规则 使用xml 其中，使用自定义注解标记切点，是侵入式的，所以这种方式在实际开发中==不推荐==，仅作为了解，另一种使用规则来定义切点的方式，无侵入，一般推荐使用这种方式。\n① 自定义注解 首先自定义一个注解：\n@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Action { } 然后在需要拦截的方法上，添加该注解，在 add 方法上添加了 @Action 注解，表示该方法将会被 Aop 拦截，而其他未添加该注解的方法则不受影响。\n@Component public class MyCalculatorImpl { @Action public int add(int a, int b) { return a + b; } public void min(int a, int b) { System.out.println(a + \u0026#34;-\u0026#34; + b + \u0026#34;=\u0026#34; + (a - b)); } } 接下来，定义增强（通知、Advice），使用统一切点，这里除了使用JoinPoint获取参数，还可以通过args获取，详见这里\n@Component @Aspect//表示这是一个切面 public class LogAspect { /** * 可以统一定义切点 */ @Pointcut(\u0026#34;@annotation(Action)\u0026#34;) public void pointcut() { } /** * @param joinPoint 包含了目标方法的关键信息 * @Before 注解表示这是一个前置通知，即在目标方法执行之前执行，注解中，需要填入切点 */ @Before(value = \u0026#34;pointcut()\u0026#34;) public void before(JoinPoint joinPoint) { Signature signature = joinPoint.getSignature(); String name = signature.getName(); System.out.println(name + \u0026#34;方法开始执行了...\u0026#34;); } /** * 后置通知 * @param joinPoint 包含了目标方法的所有关键信息 * @After 表示这是一个后置通知，即在目标方法执行之后执行 */ @After(\u0026#34;pointcut()\u0026#34;) public void after(JoinPoint joinPoint) { Signature signature = joinPoint.getSignature(); String name = signature.getName(); System.out.println(name + \u0026#34;方法执行结束了...\u0026#34;); } /** * @param joinPoint * @AfterReturning 表示这是一个返回通知，即有目标方法有返回值的时候才会触发，该注解中的 returning 属性表示目标方法返回值的变量名，这个需要和参数一一对应，注意：目标方法的返回值类型要和这里方法返回值参数的类型一致，否则拦截不到，如果想拦截所有（包括返回值为 void），则方法返回值参数可以为 Object */ @AfterReturning(value = \u0026#34;pointcut()\u0026#34;,returning = \u0026#34;r\u0026#34;) public void returing(JoinPoint joinPoint,Integer r) { Signature signature = joinPoint.getSignature(); String name = signature.getName(); System.out.println(name + \u0026#34;方法返回：\u0026#34;+r); } /** * 异常通知 * @param joinPoint * @param e 目标方法所抛出的异常，注意，这个参数必须是目标方法所抛出的异常或者所抛出的异常的父类，只有这样，才会捕获。如果想拦截所有，参数类型声明为 Exception */ @AfterThrowing(value = \u0026#34;pointcut()\u0026#34;,throwing = \u0026#34;e\u0026#34;) public void afterThrowing(JoinPoint joinPoint,Exception e) { Signature signature = joinPoint.getSignature(); String name = signature.getName(); System.out.println(name + \u0026#34;方法抛异常了：\u0026#34;+e.getMessage()); } /** * 环绕通知 * * 环绕通知是集大成者，可以用环绕通知实现上面的四个通知，这个方法的核心有点类似于在这里通过反射执行方法 * @param pjp * @return 注意这里的返回值类型最好是 Object ，和拦截到的方法相匹配 */ @Around(\u0026#34;pointcut()\u0026#34;) public Object around(ProceedingJoinPoint pjp) { Object proceed = null; try { //这个相当于 method.invoke 方法，我们可以在这个方法的前后分别添加日志，就相当于是前置/后置通知 proceed = pjp.proceed(); } catch (Throwable throwable) { throwable.printStackTrace(); } return proceed; } } 通知定义完成后，接下来在配置类中，开启包扫描和自动代理：\n@Configuration @ComponentScan @EnableAspectJAutoProxy//开启自动代理 public class JavaConfig { } 然后，在 main 方法中，开启调用：\npublic class Main { public static void main(String[] args) { AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(JavaConfig.class); MyCalculatorImpl myCalculator = ctx.getBean(MyCalculatorImpl.class); myCalculator.add(3, 4); myCalculator.min(3, 4); } } ② 使用自定义规则 使用注解是侵入式的，可以继续优化，改为非侵入式的。重新定义切点，新切点的定义就不再需要 @Action 注解了，改为更为通用的拦截方式：\n@Component @Aspect//表示这是一个切面 public class LogAspect { /** * 可以统一定义切点 * 第一个 * 表示要拦截的目标方法返回值任意（也可以明确指定返回值类型） * 第二个 * 表示包中的任意类（也可以明确指定类） * 第三个 * 表示类中的任意方法 * 最后面的两个点表示方法参数任意，个数任意，类型任意 */ @Pointcut(\u0026#34;execution(* org.javaboy.aop.commons.*.*(..))\u0026#34;) public void pointcut() { } /* 后面直接 value = \u0026#34;pointcut()\u0026#34; */ } ③ 使用xml配置 定义通知/增强，单纯定义行为，无需注解：\npublic class LogAspect { public void before(JoinPoint joinPoint) { Signature signature = joinPoint.getSignature(); String name = signature.getName(); System.out.println(name + \u0026#34;方法开始执行了...\u0026#34;); } public void after(JoinPoint joinPoint) { Signature signature = joinPoint.getSignature(); String name = signature.getName(); System.out.println(name + \u0026#34;方法执行结束了...\u0026#34;); } public void returing(JoinPoint joinPoint,Integer r) { Signature signature = joinPoint.getSignature(); String name = signature.getName(); System.out.println(name + \u0026#34;方法返回：\u0026#34;+r); } public void afterThrowing(JoinPoint joinPoint,Exception e) { Signature signature = joinPoint.getSignature(); String name = signature.getName(); System.out.println(name + \u0026#34;方法抛异常了：\u0026#34;+e.getMessage()); } public Object around(ProceedingJoinPoint pjp) { Object proceed = null; try { //这个相当于 method.invoke 方法，我们可以在这个方法的前后分别添加日志，就相当于是前置/后置通知 proceed = pjp.proceed(); } catch (Throwable throwable) { throwable.printStackTrace(); } return proceed; } } 接下来在 xml中配置 Aop：\n\u0026lt;bean class=\u0026#34;org.javaboy.aop.LogAspect\u0026#34; id=\u0026#34;logAspect\u0026#34;/\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pc1\u0026#34; expression=\u0026#34;execution(* org.javaboy.aop.commons.*.*(..))\u0026#34;/\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;logAspect\u0026#34;\u0026gt; \u0026lt;aop:before method=\u0026#34;before\u0026#34; pointcut-ref=\u0026#34;pc1\u0026#34;/\u0026gt; \u0026lt;aop:after method=\u0026#34;after\u0026#34; pointcut-ref=\u0026#34;pc1\u0026#34;/\u0026gt; \u0026lt;aop:after-returning method=\u0026#34;returing\u0026#34; pointcut-ref=\u0026#34;pc1\u0026#34; returning=\u0026#34;r\u0026#34;/\u0026gt; \u0026lt;aop:after-throwing method=\u0026#34;afterThrowing\u0026#34; pointcut-ref=\u0026#34;pc1\u0026#34; throwing=\u0026#34;e\u0026#34;/\u0026gt; \u0026lt;aop:around method=\u0026#34;around\u0026#34; pointcut-ref=\u0026#34;pc1\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; 最后，在 主方法中加载配置文件：\npublic class Main { public static void main(String[] args) { ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); MyCalculatorImpl myCalculator = ctx.getBean(MyCalculatorImpl.class); myCalculator.add(3, 4); myCalculator.min(5, 6); } } 其他 对外部引用类进行增强 假定已有外部类StudentServiceImpl，其接口为StudentService，现要对其进行增强\n//定义接口 public interface StuValidator{ //检测对象是否为空 public boolean validate(Student stu); } //实现类 public class StuValidatorImpl implements StuValidator{ @Override //判断stu是否为空 public boolean validate(Student stu){ return stu!=null; } } 然后在切面类中引入接口:\n@DeclareParents：引入新的类来增强服务 value：要增强的目标对象 defaultImpl：引入增强功能的类 @Aspect public class MyAspect{ @DeclareParents( value=\u0026#34;com.xu.StudentServiceImpl+\u0026#34;, defaultImpl=StuValidatorImpl.class ) public StuValidator stuValidator; } 使用时：\n@Autowired StudentService studentService; //强制转换 StuValidator stuValidator=(StuValidator) studentService; if(stuValidator.validator(stu)){ studentService.printStu(stu); } 实际通过动态代理，newProxyInstance传入的第二个参数，为对象数组，把StudentService和StuValidator都传入，使代理对象挂到两个接口下，能相互转换并使用方法\n上当了，有什么用。。\n通知获取参数 args(user)把连接点中名称为 user 的参数传递进来，也可以通过point.getArgs()获取所有参数\n@Before(\u0026#34;pointCut()\u0026amp;\u0026amp;args(user)\u0026#34;) public void before(JointPoint point, User user){ Object[] args=point.getArgs(); sout(\u0026#34;before..\u0026#34;); } 织入方法 Spring 允许的动态代理方式有两种，一种是JDK动态代理，还有一种是CGLIB\n其中JDK动态代理要求被代理的目标对象必须==有接口==（即为接口的实现类），当被代理的对象没有接口时，会以CGLIB运行\n多个切面 使用多个切面运行时，通过在切面类上添加@Order(num)(1,2,3\u0026hellip;)设置切面运行顺序\n","permalink":"https://iendi.github.io/en/posts/tech/spring/aop/","summary":"切面 Spring 中的 Aop 的通知类型有 5 种： 前置通知 后置通知 异常通知 返回通知 环绕通知 首先，在项目中，引入 Spring 依赖（引入 Aop 相关的依赖）： \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.9.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;","title":"AOP"},{"content":"静态代理 代理类+被代理类+公共接口\n公共接口\npublic interface Person { //上交班费 void giveMoney(); } 被代理类\n//实现公共接口，并重写方法 public class Student implements Person { private String name; public Student(String name) { this.name = name; } @Override public void giveMoney() { System.out.println(name + \u0026#34;上交班费50元\u0026#34;); } } 代理类\n//实现公共接口 public class StudentsProxy implements Person{ //被代理的学生 Student stu; //构造方法 public StudentsProxy(Person stu) { // 检测是否为Student对象 if(stu.getClass() == Student.class) { this.stu = (Student)stu; } } //代理上交班费，调用被代理学生的上交班费行为 public void giveMoney() { //可以加其他语句 stu.giveMoney(); } } 具体实现\npublic class StaticProxyTest { public static void main(String[] args) { //被代理的学生张三，他的班费上交有代理对象monitor（班长）完成 Person zhangsan = new Student(\u0026#34;张三\u0026#34;); //生成代理对象，并将张三传给代理对象 Person monitor = new StudentsProxy(zhangsan); //班长代理上交班费 monitor.giveMoney(); } } 动态代理 1. 基础知识 Proxy类：提供了创建动态代理类和实例的静态方法\nstatic InvocationHandler getInvocationHandler(Object proxy): 返回指定代理实例的调用程序 static 类\u0026lt;?\u0026gt; getProxyClass(ClassLoader loader, 类\u0026lt;?\u0026gt;... interfaces)： 给出类加载器和接口数组的代理类的 java.lang.Class对象 public static Object newProxyInstance(ClassLoader loader,\rClass\u0026lt;?\u0026gt;[] interfaces,\rInvocationHandler h) - loader：类加载器 - interfaces：代理对象绑定的接口，可以有多个 - h：代理对象的逻辑实现 InvocationHandler接口：实现代理对象的逻辑\n/** * @param proxy 代理对象 * @param method 当前方法 * @param args method方法的运行参数 * @return 方法调用结果 */ public Object invoke(Object proxy,Method method,Object[] args); 2. 实例 仍然以交班费为例，公共接口：\npublic interface Person { //上交班费 void giveMoney(); } 被代理类：\npublic class Student implements Person { private String name; public Student(String name) { this.name = name; } @Override public void giveMoney() { System.out.println(name + \u0026#34;上交班费50元\u0026#34;); } } ①创建代理类 创建StuInvocationHandler类，实现InvocationHandler接口，这个类中包含被代理对象的实例target。所有执行target的方法都会被替换成执行类中的invoke方法\npublic class StuInvocationHandler\u0026lt;T\u0026gt; implements InvocationHandler { //invocationHandler持有的被代理对象 T target; //构造方法 public StuInvocationHandler(T target) { this.target = target; } /** * proxy:代表动态代理对象 * method：代表正在执行的方法 * args：代表调用目标方法时传入的实参 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method.getName()+\u0026#34;方法开始执行...\u0026#34;); Object result = method.invoke(target, args); System.out.println(method.getName()+\u0026#34;方法执行结束...\u0026#34;); return result; } } ② 创建动态实例 通过getProxyClass\n//创建一个与代理对象相关联的 InvocationHandler InvocationHandler stuHandler = new StuInvocationHandler\u0026lt;Person\u0026gt;(stu); //使用 getProxyClass 生成动态代理类 stuProxyClass Class\u0026lt;?\u0026gt; stuProxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), new Class\u0026lt;?\u0026gt;[] {Person.class}); //获得stuProxyClass中一个带 InvocationHandler 参数的构造器 constructor（忘记了看反射那部分） Constructor\u0026lt;?\u0026gt; cons = stuProxyClass.getConstructor(InvocationHandler.class); //通过构造器cons创建动态实例 stuProxy Person stuProxy = (Person) cons.newInstance(stuHandler); 通过newProxyInstance\n//创建一个与代理对象相关联的InvocationHandler InvocationHandler stuHandler = new StuInvocationHandler\u0026lt;Person\u0026gt;(stu); //创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行stuHandler中的invoke方法 Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class\u0026lt;?\u0026gt;[]{Person.class}, stuHandler); ③ 测试 public class ProxyTest { public static void main(String[] args) { //1. //创建一个实例对象，这个对象是被代理的对象 Person zs = new Student(\u0026#34;张三\u0026#34;); //2. //通过 newProxyInstance 创建动态实例 //创建一个与代理对象相关联的InvocationHandler InvocationHandler stuHandler = new StuInvocationHandler\u0026lt;Person\u0026gt;(zs); //创建一个代理对象stuProxy来代理zs，zs的每个执行方法都会替换执行stuHandler中的invoke方法 Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class\u0026lt;?\u0026gt;[]{Person.class}, stuHandler)； //3. //代理执行上交班费的方法 stuProxy.giveMoney(); } } /* 输出： giveMoney方法开始执行... 张三上交班费50元 giveMoney方法执行结束... */ ","permalink":"https://iendi.github.io/en/posts/tech/spring/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","summary":"静态代理 代理类+被代理类+公共接口 公共接口 public interface Person { //上交班费 void giveMoney(); } 被代理类 //实现公共接口，并重写方法 public class Student implements Person { private String name; public Student(String name) { this.name = name; } @Override","title":"代理模式"},{"content":"\rBean的生命周期主要可分为4个部分：\nBean的定义：通过配置查找Bean，并将Bean定义发布到IoC容器中，此时只有定义==没有实例== Bean的初始化：创建Bean的实例对象，依赖注入（如@AutoWired等资源） Bean的生存期：在ctx关闭前存在 Bean的销毁：在ctx关闭后执行销毁 为更直观地测试生命周期，改造Teacher类，加入生命周期接口和自定义类\n@Component public class Teacher implements BeanNameAware, BeanFactoryAware, ApplicationContextAware, InitializingBean, DisposableBean { @Autowired Student student; @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException { System.out.println(\u0026#34;【\u0026#34;+this.getClass().getSimpleName()+\u0026#34;】调用setBeanFactory\u0026#34;); } @Override public void setBeanName(String s) { System.out.println(\u0026#34;【\u0026#34;+this.getClass().getSimpleName()+\u0026#34;】调用setBeanName\u0026#34;); } @Override public void destroy() throws Exception { System.out.println(\u0026#34;【\u0026#34;+this.getClass().getSimpleName()+\u0026#34;】调用destory\u0026#34;); } @Override public void afterPropertiesSet() throws Exception { System.out.println(\u0026#34;【\u0026#34;+this.getClass().getSimpleName()+\u0026#34;】调用afterPropertiesSet\u0026#34;); } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { System.out.println(\u0026#34;【\u0026#34;+this.getClass().getSimpleName()+\u0026#34;】调用setApplicationContext\u0026#34;); } /** * 自定义初始化和销毁操作 */ @PostConstruct public void init(){ System.out.println(\u0026#34;【\u0026#34;+this.getClass().getSimpleName()+\u0026#34;】执行自定义初始化操作\u0026#34;); } @PreDestroy public void des(){ System.out.println(\u0026#34;【\u0026#34;+this.getClass().getSimpleName()+\u0026#34;】执行自定义销毁操作\u0026#34;); } } 其中Student类为了观测依赖注入的时间，然后创建BeanPostProcessor实现类，重写其方法：\n@Component public class BeanPostProcessorExample implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization (Object bean, String beanName) throws BeansException { System.out.println(\u0026#34;▶BeanPostProcessor \u0026#34;+\u0026#34;调用BeforeInitial 【\u0026#34;+bean.getClass().getSimpleName()+\u0026#34;】\u0026#34;); return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\u0026#34;▶BeanPostProcessor \u0026#34;+\u0026#34;调用AfterInitial 【\u0026#34;+bean.getClass().getSimpleName()+\u0026#34;】\u0026#34;); return bean; } } 主方法：\npublic class DemoApplication { public static void main(String[] args) { AnnotationConfigApplicationContext ctx=new AnnotationConfigApplicationContext(AppConfig.class); Teacher tea = ctx.getBean(Teacher.class); ctx.close(); } } 最终测试结果：\n▶BeanPostProcessor 调用BeforeInitial 【AppConfig$$EnhancerBySpringCGLIB$$6fc4ea89】 ▶BeanPostProcessor 调用AfterInitial 【AppConfig$$EnhancerBySpringCGLIB$$6fc4ea89】 18:33:15.777 Creating shared instance of singleton bean \u0026#39;student\u0026#39; ▶BeanPostProcessor 调用BeforeInitial 【Student】 ▶BeanPostProcessor 调用AfterInitial 【Student】 18:33:15.778 Creating shared instance of singleton bean \u0026#39;teacher\u0026#39; 【Teacher】调用setBeanName 【Teacher】调用setBeanFactory 【Teacher】调用setApplicationContext ▶BeanPostProcessor 调用BeforeInitial 【Teacher】 【Teacher】执行自定义初始化操作 【Teacher】调用afterPropertiesSet ▶BeanPostProcessor 调用AfterInitial 【Teacher】 18:33:15.818 ctx - Closing 【Teacher】执行自定义销毁操作 【Teacher】调用destory 注意：\n由于BeanPostProcessor对所有的Bean都生效，因此Appconfig和Student的也会显示出来 ","permalink":"https://iendi.github.io/en/posts/tech/spring/bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","summary":"Bean的生命周期主要可分为4个部分： Bean的定义：通过配置查找Bean，并将Bean定义发布到IoC容器中，此时只有定义==没有实例==","title":"Bean 的生命周期"},{"content":"将对象的创建、初始化、销毁等操作交给 Spring 容器来管理\n本文以Student 类为例，定义如下：\npublic class Student { public String name; public Integer number; public boolean sex; //..constructor,getter and setter } 一. 创建一个简单的IOC应用 引入maven依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.9.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 在 📂resources 下创建一个 spring 的配置文件ioc.xml 引入了Student，id为该 bean 唯一标识符，通常 id 与 name一样\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.xu.ioc.Student\u0026#34; id=\u0026#34;student\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 调用容器中的 bean\npublic class Person { public static void main(String[] args) { ClassPathXmlApplicationContext ctx =new ClassPathXmlApplicationContext(\u0026#34;ioc.xml\u0026#34;); Student student = (Student) ctx.getBean(\u0026#34;student\u0026#34;); System.out.println(student); } } /* 输出： Student无参构造执行 com.xu.ioc.Student@27efef64 */ 获取配置文件的方法： ClassPathXmlApplicationContext 从 classpath 下查找配置文件 FileSystemXmlApplicationContext 从操作系统路径下去寻找配置文件 获取 Bean 的方法： 通过id或name： ctx.getBean(\u0026quot;student\u0026quot;) 通过类名：ctx.getBean(Student.class) （不推荐，当一类有多个bean时会报错） 二. Bean 的属性注入 1. 通过构造方法 需要Student 类中已定义好构造函数\n\u0026lt;bean class=\u0026#34;com.xu.ioc.Student\u0026#34; id=\u0026#34;student\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;LiHua\u0026#34;/\u0026gt; \u0026lt;constructor-arg index=\u0026#34;1\u0026#34; value=\u0026#34;119\u0026#34;/\u0026gt; \u0026lt;constructor-arg index=\u0026#34;2\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 或直接用 name 来指定\n\u0026lt;bean class=\u0026#34;com.xu.ioc.Student\u0026#34; id=\u0026#34;student\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;LiHua\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;number\u0026#34; value=\u0026#34;119\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;sex\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 2. 通过 set 方法注入 ==属性值==并不是类中定义的属性名，而是通过set方法分析得到的属性名\n\u0026lt;bean class=\u0026#34;com.xu.ioc.Student\u0026#34; id=\u0026#34;student\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;LiHua\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;number\u0026#34; value=\u0026#34;119\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;sex\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 3. 其他复杂属性注入 对象注入：通过 ref 引用对象\n\u0026lt;bean class=\u0026#34;com.xu.User\u0026#34; id=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;cat\u0026#34; ref=\u0026#34;cat\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;com.xu.Cat\u0026#34; id=\u0026#34;cat\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小白\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;color\u0026#34; value=\u0026#34;白色\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 数组注入：array 节点，也可以被list节点代替\n\u0026lt;bean class=\u0026#34;com.xu.User\u0026#34; id=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;cat\u0026#34; ref=\u0026#34;cat\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;favorites\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;足球\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;篮球\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;乒乓球\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;com.xu.Cat\u0026#34; id=\u0026#34;cat\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小白\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;color\u0026#34; value=\u0026#34;白色\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; Map 注入：\n\u0026lt;property name=\u0026#34;map\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;age\u0026#34; value=\u0026#34;99\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;name\u0026#34; value=\u0026#34;xu\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; Properties 注入：\n\u0026lt;property name=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;age\u0026#34;\u0026gt;99\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;name\u0026#34;\u0026gt;xu\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; 三. Bean 注册 1.Java 配置 通过注解和配置类实现，首先定义配置类JavaConfig\n@Configuration public class JavaConfig { @Bean Student sayHello() { return new Student(); } } @Configuration 表示这个类不是一个普通类，而是一个配置类，它的作用相当于 applicationContext.xml，@Bean 注解，将这个方法的 ==返回值== 注入 Spring 容器\n接着在主方法中添加配置类：通过AnnotationConfigApplicationContext引入配置类\npublic class Person { public static void main(String[] args) { AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(JavaConfig.class); Student hello = ctx.getBean(SayHello.class); System.out.println(hello); } } 2. 自动化配置 添加自动化注解 在 Service 层上，添加注解时，使用 @Service 在 Dao 层，添加注解时，使用 @Repository 在 Controller 层，添加注解时，使用 @Controller 在其他组件上添加注解时，使用 @Component 配置自动化扫描 通过@ComponentScan\n对配置类JavaConfig，添加@ComponentScan进行包扫描，然后在主方法中通过AnnotationConfigApplicationContext引入配置类\n@Configuration @ComponentScan(basePackages = \u0026#34;com.xu.javaconfig.service\u0026#34;) //扫描com.xu.javaconfig包下的service类 public class JavaConfig { } 扫描进容器的bean名称，默认为类名==首字母小写==，可以在注解中定义名称。\n可以自定义扫描规则，扫描指定类，如下是不扫描Controller注解进容器\n@Configuration @ComponentScan(basePackages = \u0026#34;com.xu.javaconfig\u0026#34;,useDefaultFilters = true,excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION,classes = Controller.class)}) public class JavaConfig { } 通过 xml\n在 xml 文件中添加：\n\u0026lt;context:component-scan base-package=\u0026#34;com.xu.javaconfig\u0026#34;/\u0026gt; 主方法中通过ClassPathXmlApplicationContext加载配置文件即可完成注册\n同样可以自定义扫描规则：\n\u0026lt;context:component-scan base-package=\u0026#34;com.xu.javaconfig\u0026#34; use-default-filters=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;context:exclude-filter type=\u0026#34;annotation\u0026#34; expression=\u0026#34;org.springframework.stereotype.Controller\u0026#34;/\u0026gt; \u0026lt;/context:component-scan\u0026gt; 对象注入 一般有三种对象注入方式：\n@Autowired：根据类型查找，要求该类型只能有一个Bean 可与@Qualifier注解配合，达到通过Bean名称查找的效果 @Resources：根据定义的Bean名查找 @Injected：与@Autowired类似，但需要导入javax.inject.Inject，不常用 四. Bean的生命周期 ","permalink":"https://iendi.github.io/en/posts/tech/spring/ioc/","summary":"将对象的创建、初始化、销毁等操作交给 Spring 容器来管理 本文以Student 类为例，定义如下： public class Student { public String name; public Integer number; public boolean sex; //..constructor,getter and setter } 一. 创建一个简单的I","title":"IOC"}]